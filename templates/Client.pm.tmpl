####################################################################
#
#     This file was generated using XDR::Parse version __XDR_PARSE_VERSION__
#                   and LibVirt version __LIBVIRT_TAG__
#
#      Don't edit this file, use the source template instead
#
#                 ANY CHANGES HERE WILL BE LOST !
#
####################################################################


use v5.26;
use warnings;
no warnings qw(void);
use experimental 'signatures';
use Feature::Compat::Try;
use Future::AsyncAwait;
use Object::Pad 0.821;
use Sublike::Extended 0.29 'method', 'sub'; # From XS-Parse-Sublike, used by Future::AsyncAwait

class Sys::Async::Virt __VERSION__;


use Carp qw(croak);
use Future;
use Future::IO;
use Future::Selector;
use Log::Any qw($log);
use Scalar::Util qw(reftype weaken);

use Protocol::Sys::Virt::Remote::XDR __P::S::V::VERSION__;
my $remote = 'Protocol::Sys::Virt::Remote::XDR';

use Protocol::Sys::Virt::KeepAlive __P::S::V::VERSION__;
use Protocol::Sys::Virt::Remote __P::S::V::VERSION__;
use Protocol::Sys::Virt::Transport __P::S::V::VERSION__;
use Protocol::Sys::Virt::URI __P::S::V::VERSION__; # imports parse_url

use Sys::Async::Virt::Connection::Factory __VERSION__;
use Sys::Async::Virt::Domain __VERSION__;
use Sys::Async::Virt::DomainCheckpoint __VERSION__;
use Sys::Async::Virt::DomainSnapshot __VERSION__;
use Sys::Async::Virt::Network __VERSION__;
use Sys::Async::Virt::NetworkPort __VERSION__;
use Sys::Async::Virt::NwFilter __VERSION__;
use Sys::Async::Virt::NwFilterBinding __VERSION__;
use Sys::Async::Virt::Interface __VERSION__;
use Sys::Async::Virt::StoragePool __VERSION__;
use Sys::Async::Virt::StorageVol __VERSION__;
use Sys::Async::Virt::NodeDevice __VERSION__;
use Sys::Async::Virt::Secret __VERSION__;

use Sys::Async::Virt::Callback __VERSION__;
use Sys::Async::Virt::Stream __VERSION__;

__CONSTANTS__

use constant {
    _STATE_NONE           => 0,
    _STATE_INITIALIZING   => 1,
    _STATE_INITIALIZED    => 2, # Process transports: in/out pipes have been connected
    _STATE_AUTHENTICATING => 3, # Process transports: failure to start is discovered in this state
    _STATE_AUTHENTICATED  => 4,
    _STATE_OPENING        => 5,
    _STATE_OPENED         => 6,
    _STATE_CLEANING_UP    => 7,
    _STATE_CLOSING        => 8,
    _STATE_CLOSED         => 9,
};

field $_domains            = {};
field $_domain_checkpoints = {};
field $_domain_snapshots   = {};
field $_networks           = {};
field $_network_ports      = {};
field $_nwfilters          = {};
field $_nwfilter_bindings  = {};
field $_interfaces         = {};
field $_storage_pools      = {};
field $_storage_vols       = {};
field $_node_devices       = {};
field $_secrets            = {};
field $_callbacks          = {};
field $_streams            = {};

# cached host data:
field $_maplen                  = 0; # length of the cpu map in bytes
field $_cpus                    = 0; # number of cpus in the hypervisor
field $_typed_param_string_okay = undef;


field $_url           :param = $ENV{LIBVIRT_DEFAULT_URI};
field $_readonly      :reader :param = undef;
field $_connection    :param = undef;
field $_transport     :param = undef;
field $_remote        :reader :param = undef;
field $_factory       :param = undef;
field $_keepalive     :param = undef;
field $_ping_interval :param = 60;

field $_on_close      :param = sub {};
field $_on_stream     :param = undef;
field $_on_message    :param = sub {};

field $_selector         = Future::Selector->new;
field $_completed_f      = undef;
field $_eof              = 0;
field $_state            = _STATE_NONE; # state machine
field $_replies          = {};


method _no_translation(@args) {
    return @args;
}

method _translate_remote_nonnull_domain($dom, @) {
    $self->_domain_instance( $dom );
}

method _translate_remote_nonnull_domain_checkpoint($checkpoint, @) {
    $self->_domain_checkpoint_instance( $checkpoint );
}

method _translate_remote_nonnull_domain_snapshot($snapshot, @) {
    $self->_domain_snapshot_instance( $snapshot );
}

method _translate_remote_nonnull_network($network, @) {
    $self->_network_instance( $network );
}

method _translate_remote_nonnull_network_port($network_port, @) {
    $self->_network_port_instance( $network_port );
}

method _translate_remote_nonnull_nwfilter($nwfilter, @) {
    $self->_network_nwfilter_instance( $nwfilter );
}

method _translate_remote_nonnull_nwfilter_binding($binding, @) {
    $self->_network_nwfilter_binding_instance( $binding );
}

method _translate_remote_nonnull_interface($interface, @) {
    $self->_network_interface_instance( $interface );
}

method _translate_remote_nonnull_storage_pool($pool, @) {
    $self->_storage_pool_instance( $pool );
}

method _translate_remote_nonnull_storage_vol($vol, @) {
    $self->_storage_vol_instance( $vol );
}

method _translate_remote_nonnull_node_device($device, @) {
    $self->_node_device_instance( $device );
}

method _translate_remote_nonnull_secret($secret, @) {
    $self->_secret_instance( $secret );
}

my @reply_translators = (
    __REPLY_TRANSLATORS__
);

sub _map( $client, $unwrap, $argmap, $data) {
    for my $key (keys $argmap->%*) {
        my $val = $data->{$key};

        if (ref $argmap->{$key} and reftype $argmap->{$key} eq 'HASH') {
            $data->{$key} = _map( $client, undef, $argmap->{$key}, $val );
        }
        elsif (ref $val and reftype $val eq 'ARRAY') {
            $data->{$key} = [
                map { $argmap->{$key}->( $client, $_ ) } $val->@* ];
        }
        else {
            $data->{$key} = $argmap->{$key}->( $client, $val );
        }
    }

    return $data;
}

sub _translated_msg($client, $argsmap, %args) {
    return (%args, ) unless $args{data};
    my $data = _map($client, undef, $argsmap, $args{data});
    my $msg = delete $data->{msg};
    delete $data->{callbackID};
    if ($msg) {
        $args{data} = {
            $data->%*, $msg->%*
        };
    }
    return (%args, );
}

sub _translated_reply($client, $unwrap, $argmap, %args) {
    return (%args, ) unless $args{data};
    my $data = $args{data};
    $args{data} = _map($client, $unwrap, $argmap, $data);
    if ($unwrap) {
        $args{data} = $args{data}->{$unwrap};
    }
    return (%args, );
}

sub _domain_factory {
    return Sys::Async::Virt::Domain->new( @_ );
}

sub _domain_checkpoint_factory {
    return Sys::Async::Virt::DomainCheckpoint->new( @_ );
}

sub _domain_snapshot_factory {
    return Sys::Async::Virt::DomainSnapshot->new( @_ );
}

sub _network_factory {
    return Sys::Async::Virt::Network->new( @_ );
}

sub _network_port_factory {
    return Sys::Async::Virt::NetworkPort->new( @_ );
}

sub _nwfilter_factory {
    return Sys::Async::Virt::NwFilter->new( @_ );
}

sub _nwfilter_binding_factory {
    return Sys::Async::Virt::NwFilterBinding->new( @_ );
}

sub _interface_factory {
    return Sys::Async::Virt::Interface->new( @_ );
}

sub _storage_pool_factory {
    return Sys::Async::Virt::StoragePool->new( @_ );
}

sub _storage_vol_factory {
    return Sys::Async::Virt::StorageVol->new( @_ );
}

sub _node_device_factory {
    return Sys::Async::Virt::NodeDevice->new( @_ );
}

sub _secret_factory {
    return Sys::Async::Virt::Secret->new( @_ );
}

method _domain_instance($id) {
    # Use $id->{id} as part of the cache key so we return a different domain
    # instance between the cases where the server includes an 'id' and where
    # it does not, such as:
    #   my ($off_dom) = $virt->list_all_domains->@*;
    #   my $on_dom = $off_dom->create;
    #
    # Here, $off_dom does not have an 'id' value. $on_dom has been assigned
    # an 'id' because it's running.
    my $dom_id = $id->{id} // '';
    my $key = "$dom_id/$id->{uuid}";
    my $c = $_domains->{$key};
    unless ($c) {
        $c = $_domains->{$key} = _domain_factory(
            client => $self,
            remote => $_remote,
            rpc_id => $id );
        weaken $_domains->{$key};
    }
    return $c;
}

method _domain_checkpoint_instance($id) {
    my $key = "$id->{dom}->{uuid}/$id->{name}";
    my $c = $_domain_checkpoints->{$key};
    unless ($c) {
        $c = $_domain_checkpoints->{$key} =
            _domain_checkpoint_factory(
                client => $self,
                remote => $_remote,
                rpc_id => $id );
        weaken $_domain_checkpoints->{$key};
    }
    return $c;
}

method _domain_snapshot_instance($id) {
    my $key = "$id->{dom}->{uuid}/$id->{name}";
    my $c = $_domain_snapshots->{$id->{uuid}};
    unless ($c) {
        $c = $_domain_snapshots->{$id->{uuid}} =
            _domain_snapshot_factory(
                client => $self,
                remote => $_remote,
                rpc_id => $id );
        weaken $_domain_snapshots->{$id->{uuid}};
    }
    return $c;
}

method _network_instance($id) {
    my $c = $_networks->{$id->{uuid}};
    unless ($c) {
        $c = $_networks->{$id->{uuid}} =
            _network_factory(
                client => $self,
                remote => $_remote,
                rpc_id => $id );
        weaken $_networks->{$id->{uuid}};
    }
    return $c;
}

method _network_port_instance($id) {
    my $c = $_network_ports->{$id->{uuid}};
    unless ($c) {
        $c = $_network_ports->{$id->{uuid}} =
            _network_port_factory(
                client => $self,
                remote => $_remote,
                rpc_id => $id );
        weaken $_network_ports->{$id->{uuid}};
    }
    return $c;
}

method _nwfilter_instance($id) {
    my $c = $_nwfilters->{$id->{uuid}};
    unless ($c) {
        $c = $_nwfilters->{$id->{uuid}} =
            _nwfilter_factory(
                client => $self,
                remote => $_remote,
                rpc_id => $id );
        weaken $_nwfilters->{$id->{uuid}};
    }
    return $c;
}

method _nwfilter_binding_instance($id) {
    my $key = "$id->{portdev}/$id->{filtername}";
    my $c = $_nwfilter_bindings->{$key};
    unless ($c) {
        $c = $_nwfilter_bindings->{$key} =
            _nwfilter_binding_factory(
                client => $self,
                remote => $_remote,
                rpc_id => $id );
        weaken $_nwfilter_bindings->{$key};
    }
    return $c;
}

method _interface_instance($id) {
    my $key = "$id->{mac}/$id->{name}";
    my $c = $_interfaces->{$key};
    unless ($c) {
        $c = $_interfaces->{$key} =
            _interface_factory(
                client => $self,
                remote => $_remote,
                rpc_id => $id );
        weaken $_interfaces->{$key};
    }
    return $c;
}

method _storage_pool_instance($id) {
    my $c = $_storage_pools->{$id->{uuid}};
    unless ($c) {
        $c = $_storage_pools->{$id->{uuid}} =
            _storage_pool_factory(
                client => $self,
                remote => $_remote,
                rpc_id => $id );
        weaken $_storage_pools->{$id->{uuid}};
    }
    return $c;
}

method _storage_vol_instance($id) {
    my $c = $_storage_vols->{$id->{key}};
    unless ($c) {
        $c = $_storage_vols->{$id->{key}} =
            _storage_vol_factory(
                client => $self,
                remote => $_remote,
                rpc_id => $id );
        weaken $_storage_vols->{$id->{key}};
    }
    return $c;
}

method _node_device_instance($id) {
    my $c = $_node_devices->{$id->{name}};
    unless ($c) {
        $c = $_node_devices->{$id->{name}} =
            _node_device_factory(
                client => $self,
                remote => $_remote,
                rpc_id => $id );
        weaken $_node_devices->{$id->{name}};
    }
    return $c;
}

method _secret_instance($id) {
    my $c = $_secrets->{$id->{uuid}};
    unless ($c) {
        $c = $_secrets->{$id->{uuid}} =
            _secret_factory(
                client => $self,
                remote => $_remote,
                rpc_id => $id );
        weaken $_secrets->{$id->{uuid}};
    }
    return $c;
}

async method _call($proc, $args = {}, :$unwrap = '', :$stream = '', :$empty = '') {
    die $log->fatal( "RPC call without remote connection (proc: $proc)" )
        unless $self->is_connected;
    my $serial = await $_remote->call( $proc, $args );
    my $f = Future->new;
    $log->trace( "Setting serial $serial future (proc: $proc)" );
    $_replies->{$serial} = $f;
    $_selector->add(
        data => 'reply',
        f    => $f
        );
    ### Return a stream somehow...
    my @rv = await $f;
    $rv[0] = $rv[0]->{$unwrap} if $unwrap;
    shift @rv if $empty;
    if ($stream) {
        my $s = Sys::Async::Virt::Stream->new(
            rpc_id => $serial,
            proc => $proc,
            client => $self,
            direction => ($stream eq 'write' ? 'send' : 'receive'),
            );
        $_streams->{$serial} = $s;
        weaken $_streams->{$serial};

        push @rv, $s;
    }

    return @rv;
}

async method _from_cpumap($cpumap, $offset = 0) {
    my $cpus = await $self->_cpus;
    return [ map { vec( $cpumap, $offset+$_, 1 ) } 0 .. ($cpus - 1) ];
}

async method _to_cpumap($cpuarray) {
    my $maplen = await $self->_maplen;
    my $map = "\0" x $maplen;
    vec( $map, $cpuarray->[$_] ? 1 : 0, 1 )
        for ( 0 .. scalar($cpuarray->@*) );

    return $map
}

async method _cpus() {
    return $_cpus if $_cpus;

    await $self->get_cpu_map;
    return $_cpus;
}

async method _maplen() {
    return $_maplen if $_maplen;

    await $self->get_cpu_map;
    return $_maplen;
}

async method _send($proc, $serial, :$data = undef, :$hole = undef, %rest) {
    await $_remote->stream(
        $proc, $serial,
        data => $data,
        hole => $hole);
}

async method _typed_param_string_okay() {
    return $_typed_param_string_okay //=
        ((await $self->_supports_feature(
              $_remote->DRV_FEATURE_TYPED_PARAM_STRING ))
         ? $self->TYPED_PARAM_STRING_OKAY : 0);
}

async method _filter_typed_param_string($params) {
    return await $self->_typed_param_string_okay
        ? $params
        : [ grep {
               $params->{value}->{type} != $remote->VIR_TYPED_PARAM_STRING
            } @$params ];
}

method _dispatch_closed(@args) {
    $_on_close->( $self, @args );

    # dispatch only once, on first-come-first-serve basis:
    $_on_close = sub { };
}

method _dispatch_message(:$data = undef, :$header = undef, %args) {
    if ($_keepalive) {
        $_keepalive->mark_active;
    }
    if ($data
        and defined $data->{callbackID}
        and my $cb = $_callbacks->{$data->{callbackID}}) {

        my %cbargs = $reply_translators[$header->{proc}]->(
            $self, data => $data, header => $header, %args
            );
        return $cb->_dispatch_event($cbargs{data});
    }
    else {
        my %cbargs = $reply_translators[$header->{proc}]->( $self, %args );
        return $_on_message->( $cbargs{data} );
    }
}

method _dispatch_reply(:$header, %args) {
    $log->trace( "Dispatching serial $header->{serial} / $header->{proc}" );
    if ($_keepalive) {
        $_keepalive->mark_active;
    }
    my $f = delete $_replies->{$header->{serial}};

    if (exists $args{data}) {
        my %cbargs = $reply_translators[$header->{proc}]->( $self, header => $header, %args );
        $f->done( $cbargs{data} );
    }
    elsif (exists $args{error}) {
        $f->fail( $args{error}->{message}, undef, $args{error} );
    }
    else {
        die 'Unhandled reply';
    }

    $log->trace( "Dispatching serial $header->{serial} done" );
    return $f;
}

method _dispatch_stream(:$header, %args) {
    if ($_keepalive) {
        $_keepalive->mark_active;
    }

    if (my $stream = $_streams->{$header->{serial}}) {
        if ($args{error}) {
            return $stream->_dispatch_error($args{error});
        }
        else {
            return $stream->_dispatch_receive($args{data}, $args{hole}, $args{eof}, $args{final});
        }
    }
    else {
        return $_on_stream->( $self, header => $header, %args );
    }
}

method configure(%args) {
    for my $key (keys %args) {
        $self->{$key} = $args{$key} // sub {};
    }
}

method register($r) {
    $r->configure(
        on_closed  => sub { $self->_dispatch_closed( @_ ) },
        on_message => sub { $self->_dispatch_message( @_ ) },
        on_reply   => sub { $self->_dispatch_reply( @_ ) },
        on_stream  => sub { $self->_dispatch_stream( @_ ) }
        );
    $_remote = $r;
}

async method run_once() {
    return if $_eof;
    my ($len, $type) = $_transport->need;
    $log->trace( 'Reading data from connection' );

    # closing the connection will kill the 'read' action
    my ($data, $eof) = await $_connection->read( $type, $len );
    $_keepalive->mark_active if $_keepalive and $data;
    $log->trace( 'Reading data from connection: completed' );

    return ($data, $eof);
}

method _deregister_callback($f, $proc, $id) {
    delete $_callbacks->{$id};
    my $r = $self->_call( $proc, { callbackID => $id } );
    $r->on_ready( $f ) if $f;

    $_selector->add(
        data => 'callback',
        f    => $r
    );
    return;
}

method _send_finish($proc, $serial, $abort) {
    my $r = $_remote->stream_end($proc, $serial, $abort);
    # streams send a final "OK" message; we should be awaiting that
    # instead of declaring the future $f done here

    $_selector->add(
        data => 'stream',
        f    => $r
    );
    return;
}

async method initialize() {
    return unless $_state == _STATE_NONE;
    $_state = _STATE_INITIALIZING;

    unless ($_connection) {
        $_factory    //= Sys::Async::Virt::Connection::Factory->new;
        $_connection = $_factory->create_connection( $_url,
                                                     readonly => $_readonly );
    }

    unless ($_transport) {
        $_transport = Protocol::Sys::Virt::Transport->new(
            role => 'client',
            on_send => async sub($opaque, @data) {
                await $_connection->write( @data );
                return $opaque;
            });
    }

    $_remote //= Protocol::Sys::Virt::Remote->new( role => 'client' );
    $_remote->register( $_transport );
    $self->register( $_remote );

    unless ($_connection->connected) {
        await Future->wait_any(
            $_connection->connect,
            Future::IO->sleep( 60 )
                ->then(sub { Future->fail('timeout') })
            );
    }
    $log->trace( "Connected" );
    $_selector->add( data => 'data',
                     gen  => sub { $_completed_f->is_ready ? undef : $self->run_once } );

    $_state = _STATE_INITIALIZED;
}

async method _dispatch_data( $f ) {
    my ($data, $eof) = do {
        try {
            await $f;
        }
        catch ($e) {
            $_selector->add(
                data => 'closing',
                f    => $self->_close( $self->CLOSE_REASON_ERROR )
                );
            die $e;
        }
    };


    # submit $data to $_transport, allowing $transport to raise an error
    # if the stream is terminated early.
    #
    # $_transport->receive() may return a list of futures to be awaited.
    if (my @dispatch_values = $_transport->receive($data)) {
        my $p = Future->wait_all( @dispatch_values )
            ->on_done(sub {
                $log->trace( 'Processed input data from connection' )
                      });

        # Enable async handling while we process further input from
        # the connection.
        $_selector->add( data => 'dispatch',
                         f    => $p );
    }
    if ($eof) {
        $_eof = 1;
        $log->info( 'EOF' );
        $_selector->add(
            data => 'closing',
            f    => $self->_close( $self->CLOSE_REASON_EOF )
            );
    }
}

async method run() {
    return if $_completed_f;

    my $running = 1;
    $_completed_f = Future->new->on_ready(sub { $running = 0 });
    $_selector->add( data => '',
                     f    => $_completed_f );
    while ($running) {
        my ( $tag, $f ) = await $_selector->select;
        $tag //= '';

        if ( $tag eq 'data' ) {
            await $self->_dispatch_data( $f );
        }
        else {
            await $f;
        }
    }
}

method stop() {
    croak 'Not running' unless $_completed_f;
    $_completed_f->done unless $_completed_f->is_ready;
}

method is_connected() {
    return not ($_state == _STATE_NONE
                or $_state == _STATE_INITIALIZING
                or $_state == _STATE_CLOSED);
}

method is_opened() {
    return ($_state == _STATE_OPENED);
}

method _remove_stream($id) {
    delete $_streams->{$id};
    return;
}

# ENTRYPOINT: REMOTE_PROC_CONNECT_IS_SECURE
async method is_secure() {
    return ($self->is_opened
            and $_connection->is_secure
            and await $self->_call( $remote->PROC_CONNECT_IS_SECURE,
                                    {}, unwrap => 'secure' ));
}

async method connect() {
    await $self->initialize;
    await $self->auth;
    await $self->open;
}

# ENTRYPOINT: REMOTE_PROC_CONNECT_DOMAIN_EVENT_CALLBACK_REGISTER_ANY
# ENTRYPOINT: REMOTE_PROC_CONNECT_DOMAIN_EVENT_CALLBACK_DEREGISTER_ANY
async method domain_event_register_any($eventID, $domain = undef) {
    my $dom = $domain ? $domain->rpc_id : undef;
    my $rv = await $self->_call(
        $remote->PROC_CONNECT_DOMAIN_EVENT_CALLBACK_REGISTER_ANY,
        { eventID => $eventID, dom => $dom });
    my $dereg = $remote->PROC_CONNECT_DOMAIN_EVENT_CALLBACK_DEREGISTER_ANY;
    my $cb = Sys::Async::Virt::Callback->new(
        id => $rv->{callbackID},
        client => $self,
        deregister_call => $dereg,
        factory => sub { Future->new }
        );
    $_callbacks->{$rv->{callbackID}} = $cb;
    weaken $_callbacks->{$rv->{callbackID}};

    return $cb;
}

# ENTRYPOINT: REMOTE_PROC_CONNECT_NETWORK_EVENT_REGISTER_ANY
# ENTRYPOINT: REMOTE_PROC_CONNECT_NETWORK_EVENT_DEREGISTER_ANY
async method network_event_register_any($eventID, $network = undef) {
    my $net = $network ? $network->rpc_id : undef;
    my $rv = await $self->_call(
        $remote->PROC_CONNECT_NETWORK_EVENT_REGISTER_ANY,
        { eventID => $eventID, net => $net });
    my $dereg = $remote->PROC_CONNECT_NETWORK_EVENT_DEREGISTER_ANY;
    my $cb = Sys::Async::Virt::Callback->new(
        id => $rv->{callbackID},
        client => $self,
        deregister_call => $dereg,
        factory => sub { Future->new }
        );
    $_callbacks->{$rv->{callbackID}} = $cb;

    return $cb;
}

# ENTRYPOINT: REMOTE_PROC_CONNECT_STORAGE_POOL_EVENT_REGISTER_ANY
# ENTRYPOINT: REMOTE_PROC_CONNECT_STORAGE_POOL_EVENT_DEREGISTER_ANY
async method storage_pool_event_register_any($eventID, $pool = undef) {
    my $p = $pool ? $pool->rpc_id : undef;
    my $rv = await $self->_call(
        $remote->PROC_CONNECT_STORAGE_POOL_EVENT_REGISTER_ANY,
        { eventID => $eventID, pool => $p });
    my $dereg = $remote->PROC_CONNECT_STORAGE_POOL_EVENT_DEREGISTER_ANY;
    my $cb = Sys::Async::Virt::Callback->new(
        id => $rv->{callbackID},
        client => $self,
        deregister_call => $dereg,
        factory => sub { Future->new }
        );
    $_callbacks->{$rv->{callbackID}} = $cb;

    return $cb;
}

# ENTRYPOINT: REMOTE_PROC_CONNECT_NODE_DEVICE_EVENT_REGISTER_ANY
# ENTRYPOINT: REMOTE_PROC_CONNECT_NODE_DEVICE_EVENT_DEREGISTER_ANY
async method node_device_event_register_any($eventID, $dev = undef) {
    my $d = $dev ? $dev->rpc_id : undef;
    my $rv = await $self->_call(
        $remote->PROC_CONNECT_NODE_DEVICE_EVENT_REGISTER_ANY,
        { eventID => $eventID, dev => $d });
    my $dereg = $remote->PROC_CONNECT_NODE_DEVICE_EVENT_DEREGISTER_ANY;
    my $cb = Sys::Async::Virt::Callback->new(
        id => $rv->{callbackID},
        client => $self,
        deregister_call => $dereg,
        factory => sub { Future->new }
        );
    $_callbacks->{$rv->{callbackID}} = $cb;

    return $cb;
}

# ENTRYPOINT: REMOTE_PROC_CONNECT_SECRET_EVENT_REGISTER_ANY
# ENTRYPOINT: REMOTE_PROC_CONNECT_SECRET_EVENT_DEREGISTER_ANY
async method secret_event_register_any($eventID, $secret = undef) {
    my $s = $secret ? $secret->rpc_id : undef;
    my $rv = await $self->_call(
        $remote->PROC_CONNECT_SECRET_EVENT_REGISTER_ANY,
        { eventID => $eventID, secret => $s });
    my $dereg = $remote->PROC_CONNECT_SECRET_EVENT_DEREGISTER_ANY;
    my $cb = Sys::Async::Virt::Callback->new(
        id => $rv->{callbackID},
        client => $self,
        deregister_call => $dereg,
        factory => sub { Future->new }
        );
    $_callbacks->{$rv->{callbackID}} = $cb;

    return $cb;
}

# ENTRYPOINT: REMOTE_PROC_AUTH_LIST
# ENTRYPOINT: REMOTE_PROC_AUTH_POLKIT
# ENTRYPOINT: REMOTE_PROC_AUTH_SASL_INIT

# auth( $auth_type )
#  --> clients take the selected auth mechanism from the
#      connection URL: auth='sasl[.<mech>]" / auth='none' / auth='polkit'
# in order to be able to handle SASL AUTH, we'll need an Authen::SASL
# authentication parameter to be passed in though...

async method auth($auth_type = undef) {
    return unless $_state == _STATE_INITIALIZED;
    $_state = _STATE_AUTHENTICATING;

    my $auth_types = await $self->_call( $remote->PROC_AUTH_LIST, {},
                                         unwrap => 'types' );
    my $selected;
    if (defined $auth_type) {
        my $want;
        if ($auth_type eq 'sasl') {
            $want = $remote->AUTH_SASL;
        }
        elsif ($auth_type eq 'polkit') {
            $want = $remote->AUTH_POLKIT;
        }
        elsif ($auth_type eq 'none') {
            $want = $remote->AUTH_NONE;
        }
        else {
            die "Unknown authentication method $auth_type requested";
        }

        for my $type ( $auth_types->@* ) {
            if ($want == $type) {
                $selected = $type;
                last;
            }
        }
        die "Requested authentication method $auth_type not supported by the server"
            if not defined $selected;
    }
    else {
        $selected = shift $auth_types->@*;
    }

    $log->trace( "Selected auth method: $selected" );
    if ($selected == $remote->AUTH_POLKIT) {
        await $self->_call( $remote->PROC_AUTH_POLKIT );
    }
    elsif ($selected == $remote->AUTH_SASL) {
        my $mechs = await $self->_call( $remote->PROC_AUTH_SASL_INIT, {},
                                        unwrap => 'mechlist' );
        ...
    }

    $_state = _STATE_AUTHENTICATED;
    return;
}

async method _register_keepalive() {
    if (await $self->_supports_feature(
            $_remote->DRV_FEATURE_PROGRAM_KEEPALIVE )) {
        $_keepalive //= Protocol::Sys::Virt::KeepAlive->new(
            max_inactive => 5,
            on_ack       => sub { $log->trace('KeepAlive PING ACK'); return; },
            on_ping      => sub {
                $log->trace('KeepAlive ACK-ing PING');
                return $_[0]->pong unless $_eof;
            },
            on_fail      => sub {
                $log->fatal('KeepAlive time out - closing connection');
                return $self->_close( $self->CLOSE_REASON_KEEPALIVE );
            });

        $_keepalive->register( $_transport );
        $_selector->add( data => 'PING',
                         gen  => sub {
                             Future::IO
                                 ->sleep( $_ping_interval )
                                 ->on_done(sub {
                                     $log->trace('Sending PING');
                                 })
                                 ->then(sub {
                                     $_keepalive->ping unless $_eof;
                                 })
                         });
    }
}

# ENTRYPOINT: REMOTE_PROC_CONNECT_OPEN
# ENTRYPOINT: REMOTE_PROC_CONNECT_REGISTER_CLOSE_CALLBACK
async method open() {
    return unless $_state == _STATE_AUTHENTICATED;
    $_state = _STATE_OPENING;

    await $self->_register_keepalive();
    my %parsed_url = parse_url( $_url );
    my $flags = $_readonly ? RO : 0;
    await $self->_call( $remote->PROC_CONNECT_OPEN,
                        { name => $parsed_url{name}, flags => $flags } );
    if (await $self->_supports_feature(
            $_remote->DRV_FEATURE_REMOTE_CLOSE_CALLBACK )) {
        await $self->_call( $remote->PROC_CONNECT_REGISTER_CLOSE_CALLBACK );
    }
    if (not await $self->_supports_feature(
            $_remote->DRV_FEATURE_REMOTE_EVENT_CALLBACK )) {
        die "Remote does not support REMOTE_EVENT_CALLBACK feature";
    }

    $_state = _STATE_OPENED;
}

# ENTRYPOINT: REMOTE_PROC_CONNECT_CLOSE
# ENTRYPOINT: REMOTE_PROC_CONNECT_UNREGISTER_CLOSE_CALLBACK
async method _close($reason) {
    unless (_STATE_INITIALIZED <= $_state and $_state <= _STATE_OPENED) {
        $_completed_f->done unless $_completed_f->is_ready;
        return;
    }
    $_state = _STATE_CLEANING_UP;

    unless ($_connection->is_read_eof
            or $_connection->is_write_eof) {
        # when orderly connected both for reading and writing,
        # clean up all resources the server allocated for us
        try {
            await Future->wait_all(
                (map { $_->cancel }
                 grep { $_ } values $_callbacks->%*),
                (map { $_->abort }
                 grep { $_ } values $_streams->%*)
                );
            $log->debug( 'Unregistering CLOSE CALLBACK' );
            await $self->_call(
                $remote->PROC_CONNECT_UNREGISTER_CLOSE_CALLBACK );

            $log->debug( 'Closing session' );
            await $self->_call( $remote->PROC_CONNECT_CLOSE );

            $_completed_f->done;
            await $_connection->close;
            # @@@TODO: wait for server to close the connection?
        }
        catch ($e) {
            $log->error( "Error during release of server resources: $e" );
        }
    }
    else {
        # stop loops reading from and writing to the connection
        await $_connection->close;
        # @@@TODO: wait for server to close the connection?
    }

    # These *should* have been de-allocated above; however,
    # when the connection to the server doesn't work properly
    # anymore, we want to simply discard the client side resources
    # ... the server is on its own

    $_state = _STATE_CLOSING;
    if (my @callbacks = values $_callbacks->%*) {
        $log->debug( 'Cleaning up callbacks not deregistered from the server' );
        for my $cb (@callbacks) {
            next unless $cb;

            # 'cleanup' cleans the items from the array
            $cb->cleanup;
        }
    }
    if (my @streams = values $_streams->%*) {
        $log->debug( 'Cleaning up streams not deregistered from the server' );
        for my $stream (@streams) {
            next unless $stream;

            # 'cleanup' cleans the items from the array
            $stream->cleanup;
        }
    }
    if (my @replies = keys $_replies->%*) {
        $log->debug( 'Cleaning up (failing) on-going RPC calls' );
        for my $serial (@replies) {
            my $reply = delete $_replies->{$serial};
            next unless $reply;

            $reply->fail( 'Closed before reply received' );
        }
    }

    $_state = _STATE_CLOSED;
    $self->_dispatch_closed( $reason );
    $_completed_f->done;
    return;
}

async method close() {
    return if ($_state == _STATE_NONE or _STATE_CLEANING_UP <= $_state);
    await $self->_close( $self->CLOSE_REASON_CLIENT );
}

# ENTRYPOINT: REMOTE_PROC_NODE_ALLOC_PAGES
async method alloc_pages($page_counts, $start_cell, $cell_count, $flags ) {
    my $rv = await $self->_call(
        $remote->PROC_NODE_ALLOC_PAGES,
        { pageSizes  => [ map { $_->{size} } $page_counts->@* ],
          pageCounts => [ map { $_->{count} } $page_counts->@* ],
          startCell  => $start_cell,
          cellCount  => $cell_count,
          flags      => $flags } );

    return $rv->{ret};
}

# ENTRYPOINT: REMOTE_PROC_NODE_GET_CELLS_FREE_MEMORY
async method get_cells_free_memory($start_cell, $max_cells) {
    my $rv = await $self->_call(
        $remote->PROC_NODE_GET_CELLS_FREE_MEMORY,
        { startCell => $start_cell, maxcells => $max_cells } );

    return $rv->{cells};
}

# ENTRYPOINT: REMOTE_PROC_NODE_GET_CPU_MAP
async method get_cpu_map() {
    my $rv = await $self->_call(
        $remote->PROC_NODE_GET_CPU_MAP,
        { need_map => 1, need_online => 1, flags => 0 } );

    $_cpus = $rv->{ret};
    $_maplen = length($rv->{cpumap});

    return {
        totcpus => $rv->{ret},
        totonline => $rv->{online},
        maplen    => length($rv->{cpumap}),
        onlinemap => await $self->_from_cpumap( $rv->{cpumap} )
    };
}

# ENTRYPOINT: REMOTE_PROC_NODE_GET_FREE_PAGES
async method get_free_pages($pages, $start_cell, $cell_count, $flags = 0) {
    my $rv = await $self->_call(
        $remote->PROC_NODE_GET_FREE_PAGES,
        { pages => $pages, startCell => $start_cell,
          cellCount => $cell_count, flags => $flags // 0 } );

    my @rv;
    my $cell_counts = [];
    while (1) {
        my $count = shift $rv->{counts}->@*;
        push $cell_counts->@*, $count;

        if (scalar($cell_counts->@*) == scalar($pages->@*)) {
            push @rv, $cell_counts;
            $cell_counts = [];
        }
        if (scalar($rv->{counts}->@*) == 0) {
            last;
        }
    }

    return \@rv;
}

__CALLS__

1;

__END__

=head1 NAME

Sys::Async::Virt - LibVirt protocol implementation for clients

=head1 VERSION

__VERSION__

Based on LibVirt tag __LIBVIRT_TAG__

=head1 SYNOPSIS

  use Future::AsyncAwait;

  use Future;
  use Sys::Async::Virt;

  async sub main( $client ) {
     await $client->connect;
     my $domains = await $client->list_all_domains;

     await $virt->close;
     $virt->stop;
  }

  my $client = Sys::Async::Virt->new(url => 'qemu:///system');
  await Future->needs_all(
     $client->run,
     main( $client )
  );


=head1 DESCRIPTION

This module manages access to a LibVirt service through its remote protocol.

The API documentation of this module and the related modules
C<Sys::Async::Virt::*> is meant to be used in conjunction with the
documentation found at L<LibVirt's API
reference|https://libvirt.org/html/index.html>.  Since the C API is procedural
whereas the Perl API is object oriented, the mapping of API entry points isn't
one-to-one.  Each entry point links to its C API equivalent on the libvirt.org
site, enabling users to quickly find documentation.  (Please report any
broken links.)

An important difference with the C API is that this API only lists the
C<INPUT> and C<INPUT|OUTPUT (as input)> arguments for its functions.  The
C<OUTPUT> and C<INPUT|OUTPUT (as output)> arguments will be returned from
the function call (in a hash, if multiple values are to be returned):

  my $cpumap = $client->get_cpu_map;
  # $cpumap is a hash with the elements of the 'cpumap' LibVirt elements

=head2 Data type differences between C and Perl API

=head3 cpumap

In the C API, C<cpumap> and C<cpumaps> parameters are bitmap fields. In the
Perl API, these bitmap fields are converted to arrays of booleans:

  # use:
  $cpumap->[$cpu_index]

  # to achieve this from the C API:
  cpumap & (1 << cpu_index)

=head3 Typed parameter values

The C API returns (arrays of) typed parameters in several places. The Perl API
represents typed parameters as a hash with two keys: C<field> (a string, the
name of the parameter) and C<value>. The C<value> is itself a hash with two
keys: C<type> (indicating the type, from L<virTypedParameterType|https://libvirt.org/html/libvirt-libvirt-common.html#virTypedParameterType>)
and one of C<i>, C<ui>, C<l>, C<ul>, C<d>, C<b> or C<s>, the actual typed
value.

=head2 RUNNING AGAINST OLDER SERVERS

The reference LibVirt version of this module is __LIBVIRT_TAG__. This means
all API entry points have been implemented as they are declared in the
protocol of that version (except for the ones listed in the section
L</UNIMPLEMENTED ENTRYPOINTS>).  The consequence of a server being of a lower
version is that some entry points will throw errors when being used, if not
supported by the server.

=head2 RUNNING AGAINST NEWER SERVERS

The module can run against any version of LibVirt newer than __LIBVIRT_TAG__;
any new entry points in the API will not be available, but all existing APIs
can be used as per the stability guarantees.

=head2 STABILITY GUARANTEES

The modules in this distribution are considered B<experimental>, meaning that
no interface guarantees are made at this time.  However, since the protocol
description from which most of the code is generated, changes are anticipated
to be minimal.  The more feedback the project receives, the sooner the project
will be able to commit to the API as it is.

=head2 ASYNCHRONOUS INVOCATIONS

The API calls in these modules invoke remote procedure calls (RPC) on a
LibVirt server (which may run locally). The return values are L<Future>s
which can be C<await>ed using L<Future::AsyncAwait>.  Many calls start a
process on the server without awaiting the result.  One example is the
C<< $domain->shutdown() >> invocation: it returns when shutdown has been
initiated, not when the domain is actually shut off. Domain life cycle
events can be used to learn about domain state changes.
Other calls query the server for state (such as C<< $domain->get_state() >>)
and return the state when the server replies to the invocation.

The LibVirt protocol and server support concurrent requests: requests
issued before earlier requests have finished. The server responds as soon
as the result is available. This means that server replies may come back
out-of-order, resolving futures as results become available. The use of
C<async> and C<await> help to await results from the server and continue
processing as soon as results become available.

=head1 CLIENT EVENTS

=head2 on_message

  $on_message->( @@@TODO );

Receives all messages which either don't classify as a callback invocation
(i.e. the return value structure doesn't have a C<callbackID> member), or
for which no callback has been registered through one of the callback
registration functions.

=head2 on_close

  $on_close->( $client, $reason );

=head1 LIBVIRT EVENTS

=head2 domain_event_register_any

  $cb = await $client->domain_event_register_any( $event_id, $dom = undef );

Subscribes to events of type C<$event_id>. Restricts events to a specific
domain by passing a value into C<$dom>. Please refer to the LibVirt
documentation for the L<list of available domain related
events|https://libvirt.org/html/libvirt-libvirt-domain.html#virDomainEventID>.

Returns a L<Sys::Async::Virt::Callback> instance.

Example:

  my $cb = $client->domain_event_register_any( $client->DOMAIN_EVENT_ID_LIFECYCLE );
  my $event_data = await $cb->next_event;
  # { dom => $dom, event => $event, detail => $detail }

The domain event id documentation refers to various callbacks, which are
called (in the C API) with a list of arguments. C<$event_data> will generally
contain the same values, except the C<conn> (which is
available through C<dom>) and the C<opaque> parameters. Refer to
L<virConnectDomainEventGenericCallback|https://libvirt.org/html/libvirt-libvirt-domain.html#virConnectDomainEventGenericCallback>
to compare the definition of the callback function and the returned
C<$event_data> above.

=head2 network_event_register_any

  $cb = await $client->network_event_register_any( $event_id, $net = undef );

Subscribes to events of type C<$event_id>. Restricts events to a specific
network by passing a value into C<$net>. Similar to
C<domain_event_register_any>; please refer to the LibVirt
documentation for the L<list of available network related
events|https://libvirt.org/html/libvirt-libvirt-network.html#virNetworkEventID>.

Returns a L<Sys::Async::Virt::Callback> instance.

=head2 node_device_event_register_any

  $cb = await $client->node_device_event_register_any( $event_id, $dev = undef );

Subscribes to events of type C<$event_id>. Restricts events to a specific
device by passing a value into C<$dev>. Similar to
C<domain_event_register_any>; please refer to the LibVirt
documentation for the L<list of available node device related
events|https://libvirt.org/html/libvirt-libvirt-nodedev.html#virNodeDeviceEventID>.

Returns a L<Sys::Async::Virt::Callback> instance.

=head2 secret_event_register_any

  $cb = await $client->secret_event_register_any( $event_id, $secret = undef);

Subscribes to events of type C<$event_id>. Restricts events to a specific
secret by passing a value into C<$secret>. Similar to
C<domain_event_register_any>; please refer to the LibVirt
documentation for the L<list of available secret related
events|https://libvirt.org/html/libvirt-libvirt-secret.html#virSecretEventID>.

Returns a L<Sys::Async::Virt::Callback> instance.

=head2 storage_pool_event_register_any

  $cb = await $client->storage_pool_event_register_any( $event_id, $pool = undef );

Subscribes to events of type C<$event_id>. Restricts events to a specific
storage pool by passing a value into C<$pool>. Similar to
C<domain_event_register_any>; please refer to the LibVirt
documentation for the L<list of available storage (pool) related
events|https://libvirt.org/html/libvirt-libvirt-storage.html#virStoragePoolEventID>.

Returns a L<Sys::Async::Virt::Callback> instance.

=head1 CONSTRUCTOR

=head2 new

  $client = Sys::Async::Virt->new( url => $url, ... );

Creates a new client instance.  The constructor supports these parameters:

=over 8

=item * C<factory> (optional)

An instance of L<Sys::Async::Virt::Connection::Factory> or derived class. Not
required when the C<connection> parameter is supplied.

=item * C<connection> (optional)

An instance of L<Sys::Async::Virt::Connection> or derived class.  The
C<connect> method will be called to establish the actual connection.

=item * C<transport> (optional)

An instance of L<Protocol::Sys::Virt::Transport> or derived class configured
to send the output through the C<connection> passed in.

=item * C<remote> (optional)

An instance of L<Protocol::Sys::Virt::Remote> or derived class configured
in a C<client> role.  The C<remote> will be registered with the C<tranport>
as part of the C<connect> procedure.

=item * C<keepalive> (optional)

An instance of L<Protocol::Sys::Virt::KeepAlive> or derived class configured
to reply to PING messages using a PONG message as well as closing the
C<connection> when the keepalive threshold is exceeded.

=item * C<ping_interval> (optional)

Interval in seconds between PING messages sent. Please keep in mind that the
keepalive threshold is in number of messages not responded to, meaning that
with a C<ping_interval> of 60 and a threshold of 5, it will take 5 minutes
before a dead connection will be killed, if the operating system doesn't throw
an error before it.

When not supplied, defaults to C<60>.

=item * C<url> (optional)

The URL of the hypervisor to connect to as per L<https://libvirt.org/uri.html>.

When not supplied, defaults to the environment variable C<LIBVIRT_DEFAULT_URI>.

=back

=head1 METHODS

=head2 configure

=head2 register

  $client->register( $remote );

=head2 run

   my $run_f = $client->run;

Returns a future which resolves when the connection is explicitly stopped
(through C<< $client->stop >>) or upon a connection error.

=head2 run_once

  my $run_f = $client->run_once;

Returns a future which resolves when the next data frame from the connection
has been processed. When no frame is pending, waits for the next frame to be
sent on the connection.

=head2 stop

  $client->stop;

Marks the future returned by the C< run > method as resolved, stopping
all processing related to the connection to the server.

=head2 initialize

  await $client->initialize;

Sets up and connects a low-level connection, if one doesn't already exist. Then
proceeds to set up a transport to encode data to be sent over the connection.
Finally, it creates an RPC (remote call procedure) proxy and links the three
together.

B<Note> This function requires that the C<run> method has been called and its
future is being awaited.

=head2 connect

  await $client->connect;

Calls the C<initialize>, C<auth> and C<open> methods returning a future which
completes when all three have completed.

=head2 auth

  await $client->auth( $auth_type = undef );
  # -> (* no data *)

Authenticates against the server. C<$auth_type> can be any of:

=over 8

=item * C<none>

=item * C<sasl>

=item * C<polkit>

=back

When no C<$auth_type> is passed, the first authentication method announced
by the server, is used.

=head2 is_connected

  my $bool = $client->is_connected;


=head2 is_opened

  my $bool = $client->is_opened;


=head2 is_secure

  my $bool = await $client->is_secure;


=head2 open

  await $client->open();
  # -> (* no data *)

This function opens the connection to the remote driver C<< $client->{url} >>
as passed to C< new > and documented in
L<LibVirt's Connection URIs|https://libvirt.org/uri.html>.  Note that the value
is to be the B<local> hypervisor URI as applicable to the remote end of the
connection.

=head2 close

  await $client->close;
  # -> (* no data *)

Announces to the remote the intent to close the connection. The client will
receive a confirmation message from the server after which the server will
close the connection.

=head2 alloc_pages

  $adjusted_cells = await $client->alloc_pages( $page_counts, $start_cell, $cell_count, $flags );

The C<pageSizes> and C<pageCounts> parameters of the C API have been combined into the C<$page_counts>
parameter, which is an array of hashes with a C<size> and C<count> key:

  $page_counts = [ { size => 4,    count => 800 },
                   { size => 2048, count => 400 } ];

Also see documentation of L<virNodeAllocPages|https://libvirt.org/html/libvirt-libvirt-host.html#virNodeAllocPages>.

=head2 get_cells_free_memory

  $cell_free_mem = await $client->get_cells_free_memory( $start_cell_no, $max_cells );

Returns an array of available memory per NUMA cell starting at number C<$start_cell_no>;
returns data of at most C<$max_cells> NUMA cells.

Also see documentation of L<virNodeGetCellsFreeMemory|https://libvirt.org/html/libvirt-libvirt-host.html#virNodeGetCellsFreeMemory>.

=head2 get_cpu_map

  await $client->get_cpu_map;
  # -> { maplen => $numbytes, totcpus => $cpu_count, totonline => $onl_count, onlinemap => \@online }

Returns the total number of CPUs C<$cpu_count> in the hypervisor, where the number of online
CPUs is C<$onl_count>. C<@online> is an array of length C<$cpu_count>, indicating for each CPU number
whether or not it is online.

In addition to the LibVirt and Sys::Virt APIs, this API returns C<maplen>: the length (in bytes) of CPU
maps on this hypervisor.

Also see documentation of L<virNodeGetCPUMap|https://libvirt.org/html/libvirt-libvirt-host.html#virNodeGetCPUMap>.

=head2 get_free_pages

  $pages = [ 4, 2048 ];
  $free_cell_pages = await $client->get_free_pages( $pages, $start_cell, $cell_count );

Returns a reference to an array (one element per NUMA cell) of arrays with the number of
free pages of the sizes listed in C<$pages>.

Also see documentation of L<virNodeGetFreePages|https://libvirt.org/html/libvirt-libvirt-host.html#virNodeGetFreePages>.

__ENTRYPOINTS__

=head1 CONSTANTS


__CONSTANTS_POD_PREAMBLE__


=over 8

__CONSTANTS_POD__

=back

=head1 INTERNAL METHODS

=head2 _call

This method forwards protocol "calls" to the C<remote> instance.  Using this
wrapper allows for tracking all calls allowing to set up handling of the
replies.

=head2 _send

=head2 _send_end

=head2 _dispatch_message

=head2 _dispatch_reply

=head2 _dispatch_stream

__PRIVATE_EPS__

=head1 BUGS AND LIMITATIONS

=over 8

=item * Talking to servers without the REMOTE_EVENT_CALLBACK feature
 (v1.3.3 - 2016-04-06) is not - currently - supported

=begin fill-templates

# ENTRYPOINT: REMOTE_PROC_CONNECT_DOMAIN_EVENT_DEREGISTER
# ENTRYPOINT: REMOTE_PROC_CONNECT_DOMAIN_EVENT_DEREGISTER_ANY
# ENTRYPOINT: REMOTE_PROC_CONNECT_DOMAIN_EVENT_REGISTER
# ENTRYPOINT: REMOTE_PROC_CONNECT_DOMAIN_EVENT_REGISTER_ANY

=end fill-templates

=item * Talking to servers without the MIGRATION_PARAM feature
 (v1.1.0 - 2013-07-01) is not - currently - supported

=begin fill-templates

# ENTRYPOINT: REMOTE_PROC_DOMAIN_MIGRATE_PREPARE
# ENTRYPOINT: REMOTE_PROC_DOMAIN_MIGRATE_BEGIN
# ENTRYPOINT: REMOTE_PROC_DOMAIN_MIGRATE_PERFORM
# ENTRYPOINT: REMOTE_PROC_DOMAIN_MIGRATE_CONFIRM
# ENTRYPOINT: REMOTE_PROC_DOMAIN_MIGRATE_FINISH

# ENTRYPOINT: REMOTE_PROC_DOMAIN_MIGRATE_PREPARE2
# ENTRYPOINT: REMOTE_PROC_DOMAIN_MIGRATE_BEGIN2
# ENTRYPOINT: REMOTE_PROC_DOMAIN_MIGRATE_PERFORM2
# ENTRYPOINT: REMOTE_PROC_DOMAIN_MIGRATE_CONFIRM2
# ENTRYPOINT: REMOTE_PROC_DOMAIN_MIGRATE_FINISH2

# ENTRYPOINT: REMOTE_PROC_DOMAIN_MIGRATE_PREPARE3
# ENTRYPOINT: REMOTE_PROC_DOMAIN_MIGRATE_BEGIN3
# used in domain migrations: ENTRYPOINT: REMOTE_PROC_DOMAIN_MIGRATE_PERFORM3
# ENTRYPOINT: REMOTE_PROC_DOMAIN_MIGRATE_CONFIRM3
# ENTRYPOINT: REMOTE_PROC_DOMAIN_MIGRATE_FINISH3

# ENTRYPOINT: REMOTE_PROC_DOMAIN_MIGRATE_PREPARE_TUNNEL
# ENTRYPOINT: REMOTE_PROC_DOMAIN_MIGRATE_PREPARE_TUNNEL3

=end fill-templates

=item * Talking to servers without the MIGRATE_CHANGE_PROTECTION feature
 (v0.10.0 - 2012-08-29) is not - currently - supported

=back

=head2 TODO

=over 8

=item * Modules implementing connections for various protocols (tcp, tls, etc)

=item * C<@generate: none> entrypoints review (and implement relevant ones)

=item * libvirt client configuration (C</etc/libvirt/libvirt.conf> (for C<root>)
 or C<$XDG_CONFIG_HOME/libvirt/libvirt.conf> (for other users))

=back

=head2 UNIMPLEMENTED ENTRYPOINTS

The following entrypoints have not been implemented yet; contributions
towards implementation are greatly appreciated.

=over 8

__UNIMPLEMENTED__

=back

=head1 SEE ALSO

L<LibVirt|https://libvirt.org>, L<Sys::Virt>

=head1 LICENSE AND COPYRIGHT

  Copyright (C) 2024-2026 Erik Huelsmann

All rights reserved. This program is free software;
you can redistribute it and/or modify it under the same terms as Perl itself.
