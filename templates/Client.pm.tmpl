####################################################################
#
#     This file was generated using XDR::Parse version __XDR_PARSE_VERSION__
#                   and LibVirt version __LIBVIRT_TAG__
#
#      Don't edit this file, use the source template instead
#
#                 ANY CHANGES HERE WILL BE LOST !
#
####################################################################


use v5.20;
use warnings;
no warnings qw(void);
use experimental 'signatures';
use Feature::Compat::Try;
use Future::AsyncAwait;
use Sublike::Extended; # From XS-Parse-Sublike, used by Future::AsyncAwait

package Sys::Async::Virt __VERSION__;

use parent qw(IO::Async::Notifier);

use Carp qw(croak);
use Future::Queue;
use Log::Any qw($log);
use Scalar::Util qw(reftype weaken);

use Protocol::Sys::Virt::Remote::XDR __P::S::V::VERSION__;
my $remote = 'Protocol::Sys::Virt::Remote::XDR';

use Protocol::Sys::Virt::Remote __P::S::V::VERSION__;
use Protocol::Sys::Virt::Transport __P::S::V::VERSION__;

use Sys::Async::Virt::Connection::Factory __VERSION__;
use Sys::Async::Virt::Domain __VERSION__;
use Sys::Async::Virt::DomainCheckpoint __VERSION__;
use Sys::Async::Virt::DomainSnapshot __VERSION__;
use Sys::Async::Virt::Network __VERSION__;
use Sys::Async::Virt::NetworkPort __VERSION__;
use Sys::Async::Virt::NwFilter __VERSION__;
use Sys::Async::Virt::NwFilterBinding __VERSION__;
use Sys::Async::Virt::Interface __VERSION__;
use Sys::Async::Virt::StoragePool __VERSION__;
use Sys::Async::Virt::StorageVol __VERSION__;
use Sys::Async::Virt::NodeDevice __VERSION__;
use Sys::Async::Virt::Secret __VERSION__;

use Sys::Async::Virt::Callback __VERSION__;
use Sys::Async::Virt::Stream __VERSION__;

__CONSTANTS__


sub _no_translation {
    shift; # $client
    return @_;
}

sub _translate_remote_nonnull_domain {
    $_[0]->_domain_instance( $_[1] );
}

sub _translate_remote_nonnull_domain_checkpoint {
    $_[0]->_domain_checkpoint_instance( $_[1] );
}

sub _translate_remote_nonnull_domain_snapshot {
    $_[0]->_domain_snapshot_instance( $_[1] );
}

sub _translate_remote_nonnull_network {
    $_[0]->_network_instance( $_[1] );
}

sub _translate_remote_nonnull_network_port {
    $_[0]->_network_port_instance( $_[1] );
}

sub _translate_remote_nonnull_nwfilter {
    $_[0]->_network_nwfilter_instance( $_[1] );
}

sub _translate_remote_nonnull_nwfilter_binding {
    $_[0]->_network_nwfilter_binding_instance( $_[1] );
}

sub _translate_remote_nonnull_interface {
    $_[0]->_network_interface_instance( $_[1] );
}

sub _translate_remote_nonnull_storage_pool {
    $_[0]->_storage_pool_instance( $_[1] );
}

sub _translate_remote_nonnull_storage_vol {
    $_[0]->_storage_vol_instance( $_[1] );
}

sub _translate_remote_nonnull_node_device {
    $_[0]->_node_device_instance( $_[1] );
}

sub _translate_remote_nonnull_secret {
    $_[0]->_secret_instance( $_[1] );
}

my @reply_translators = (
    __REPLY_TRANSLATORS__
);


sub _map( $client, $unwrap, $argmap, $data) {
    for my $key (keys %{ $argmap }) {
        my $val = $data->{$key};

        if (ref $argmap->{$key} and reftype $argmap->{$key} eq 'HASH') {
            $data->{$key} = _map( $client, undef, $argmap->{$key}, $val );
        }
        elsif (ref $val and reftype $val eq 'ARRAY') {
            $data->{$key} = [ map { $argmap->{$key}->( $client, $_ ) } @{ $val } ];
        }
        else {
            $data->{$key} = $argmap->{$key}->( $client, $val );
        }
    }

    return $data;
}

sub _translated($client, $unwrap, $argmap, %args) {
    return (%args, ) unless $args{data};
    my $data = $args{data};
    $args{data} = _map($client, $unwrap, $argmap, $data);
    if ($unwrap) {
        $args{data} = $args{data}->{$unwrap};
    }
    return (%args, );
}

sub _domain_factory {
    return Sys::Async::Virt::Domain->new( @_ );
}

sub _domain_checkpoint_factory {
    return Sys::Async::Virt::DomainCheckpoint->new( @_ );
}

sub _domain_snapshot_factory {
    return Sys::Async::Virt::DomainSnapshot->new( @_ );
}

sub _network_factory {
    return Sys::Async::Virt::Network->new( @_ );
}

sub _network_port_factory {
    return Sys::Async::Virt::NetworkPort->new( @_ );
}

sub _nwfilter_factory {
    return Sys::Async::Virt::NwFilter->new( @_ );
}

sub _nwfilter_binding_factory {
    return Sys::Async::Virt::NwFilterBinding->new( @_ );
}

sub _interface_factory {
    return Sys::Async::Virt::Interface->new( @_ );
}

sub _storage_pool_factory {
    return Sys::Async::Virt::StoragePool->new( @_ );
}

sub _storage_vol_factory {
    return Sys::Async::Virt::StorageVol->new( @_ );
}

sub _node_device_factory {
    return Sys::Async::Virt::NodeDevice->new( @_ );
}

sub _secret_factory {
    return Sys::Async::Virt::Secret->new( @_ );
}

sub new {
    my ($class, %args) = @_;
    my $self = bless {
        _domains => {},
        _domain_checkpoints => {},
        _domain_snapshots   => {},
        _networks => {},
        _network_ports => {},
        _nwfilters => {},
        _nwfilter_bindings => {},
        _interfaces => {},
        _storage_pools => {},
        _storage_vols => {},
        _node_devices => {},
        _secrets => {},
        _callbacks => {},

        _replies => {},
        _streams => {},

        domain_factory            => \&_domain_factory,
        domain_checkpoint_factory => \&_domain_checkpoint_factory,
        domain_snapshot_factory   => \&_domain_snapshot_factory,
        network_factory           => \&_network_factory,
        network_port_factory      => \&_network_port_factory,
        nwfilter_factory          => \&_nwfilter_factory,
        nwfilter_binding_factory  => \&_nwfilter_binding_factory,
        interface_factory         => \&_interface_factory,
        storage_pool_factory      => \&_storage_pool_factory,
        storage_vol_factory       => \&_storage_vol_factory,
        node_device_factory       => \&_node_device_factory,
        secret_factory            => \&_secret_factory,

        url        => $args{url},
        connection => $args{connection},
        transport  => $args{transport},
        remote     => $args{remote},
        factory    => $args{factory},
        keepalive  => $args{keepalive},
        on_stream  => $args{on_stream},
    }, $class;

    return $self;
}

sub _domain_instance {
    my ($self, $id) = @_;
    my $c = $self->{_domains}->{$id->{uuid}}
       //= $self->{domain_factory}->( client => $self, remote => $self->{remote}, id => $id );
    weaken $self->{_domains}->{$id->{uuid}};
    return $c;
}

sub _domain_checkpoint_instance {
    my ($self, $id) = @_;
    my $key = "$id->{dom}->{uuid}/$id->{name}";
    my $c = $self->{_domain_checkpoints}->{$key}
       //= $self->{domain_checkpoint_factory}->( client => $self, remote => $self->{remote}, id => $id );
    weaken $self->{_domain_checkpoints}->{$key};
    return $c;
}

sub _domain_snapshot_instance {
    my ($self, $id) = @_;
    my $key = "$id->{dom}->{uuid}/$id->{name}";
    my $c = $self->{_domain_snapshots}->{$id->{uuid}}
       //= $self->{domain_snapshot_factory}->( client => $self, remote => $self->{remote}, id => $id );
    weaken $self->{_domain_snapshots}->{$id->{uuid}};
    return $c;
}

sub _network_instance {
    my ($self, $id) = @_;
    my $c = $self->{_networks}->{$id->{uuid}}
       //= $self->{network_factory}->( client => $self, remote => $self->{remote}, id => $id );
    weaken $self->{_networks}->{$id->{uuid}};
    return $c;
}

sub _network_port_instance {
    my ($self, $id) = @_;
    my $c = $self->{_network_ports}->{$id->{uuid}}
       //= $self->{network_port_factory}->( client => $self, remote => $self->{remote}, id => $id );
    weaken $self->{_network_ports}->{$id->{uuid}};
    return $c;
}

sub _nwfilter_instance {
    my ($self, $id) = @_;
    my $c = $self->{_nwfilters}->{$id->{uuid}}
       //= $self->{nwfilter_factory}->( client => $self, remote => $self->{remote}, id => $id );
    weaken $self->{_nwfilters}->{$id->{uuid}};
    return $c;
}

sub _nwfilter_binding_instance {
    my ($self, $id) = @_;
    my $key = "$id->{portdev}/$id->{filtername}";
    my $c = $self->{_nwfilter_bindings}->{$key}
       //= $self->{nwfilter_binding_factory}->( client => $self, remote => $self->{remote}, id => $id );
    weaken $self->{_nwfilter_bindings}->{$key};
    return $c;
}

sub _interface_instance {
    my ($self, $id) = @_;
    my $key = "$id->{mac}/$id->{name}";
    my $c = $self->{_interfaces}->{$key}
       //= $self->{interface_factory}->( client => $self, remote => $self->{remote}, id => $id );
    weaken $self->{_interfaces}->{$key};
    return $c;
}

sub _storage_pool_instance {
    my ($self, $id) = @_;
    my $c = $self->{_storage_pools}->{$id->{uuid}}
       //= $self->{storage_pool_factory}->( client => $self, remote => $self->{remote}, id => $id );
    weaken $self->{_storage_pools}->{$id->{uuid}};
    return $c;
}

sub _storage_vol_instance {
    my ($self, $id) = @_;
    my $c = $self->{_storage_vols}->{$id->{key}}
       //= $self->{storage_vol_factory}->( client => $self, remote => $self->{remote}, id => $id );
    weaken $self->{_storage_vols}->{$id->{key}};
    return $c;
}

sub _node_device_instance {
    my ($self, $id) = @_;
    my $c = $self->{_node_devices}->{$id->{name}}
       //= $self->{node_device_factory}->( client => $self, remote => $self->{remote}, id => $id );
    weaken $self->{_node_devices}->{$id->{name}};
    return $c;
}

sub _secret_instance {
    my ($self, $id) = @_;
    my $c = $self->{_secrets}->{$id->{uuid}}
       //= $self->{secret_factory}->( client => $self, remote => $self->{remote}, id => $id );
    weaken $self->{_secrets}->{$id->{uuid}};
    return $c;
}

extended async sub _call($self, $proc, $args = {}, :$unwrap = '', :$stream = '', :$empty = '') {
    my $serial = await $self->{remote}->call( $proc, $args );
    my $f = $self->loop->new_future;
    $log->trace( "Setting serial $serial future (proc: $proc)" );
    $self->{_replies}->{$serial} = $f;
    ### Return a stream somehow...
    my @rv = await $f;
    $rv[0] = $rv[0]->{$unwrap} if $unwrap;
    shift @rv if $empty;
    if ($stream) {
        my $s = Sys::Async::Virt::Stream->new(
            id => $serial,
            proc => $proc,
            client => $self,
            direction => ($stream eq 'write' ? 'send' : 'receive'),
            );
        $self->{_streams}->{$serial} = $s;
        weaken $self->{_streams}->{$serial};
        $self->add_child( $s );

        push @rv, $s;
    }
    return @rv;
}

async sub _send($self, $proc, $serial, %args) {
    await $self->{remote}->stream(
        $proc, $serial,
        data => $args{data},
        hole => $args{hole});
}

async sub _send_finish($self, $proc, $serial, $abort) {
    await $self->{remote}->stream_end($proc, $serial, $abort);
}

async sub _typed_param_string_okay($self) {
    return $self->{_typed_param_string_okay} //=
        ((await $self->_supports_feature(
              $self->{remote}->DRV_FEATURE_TYPED_PARAM_STRING ))
         ? $self->TYPED_PARAM_STRING_OKAY : 0);
}

async sub _filter_typed_param_string($self, $params) {
    return await $self->_typed_param_string_okay
        ? $params
        : [ grep {
               $params->{value}->{type} != $remote->VIR_TYPED_PARAM_STRING
            } @$params ];
}

sub _dispatch_closed {
    my $self = shift;

    $self->{on_closed}->( @_ );
}

sub _dispatch_message($self, %args) {
    if ($args{data}
        and defined $args{data}->{callbackID}
        and my $cb = $self->{_callbacks}->{$args{data}->{callbackID}}) {

        my %cbargs =
            $reply_translators[$args{header}->{proc}]->( $self, %args );
        $cb->_dispatch_event($cbargs{data});
    }
    else {
        my %cbargs =
            $reply_translators[$args{header}->{proc}]->( $self, %args );
        $self->{on_message}->( $cbargs{data} );
    }
}

sub _dispatch_reply {
    my ($self, %args) = @_;
    $log->trace( "Dispatching serial $args{header}->{serial}" );
    my $f = delete $self->{_replies}->{$args{header}->{serial}};

    if (exists $args{data}) {
        my %cbargs = $reply_translators[$args{header}->{proc}]->( @_ );
        $f->done( $cbargs{data} );
    }
    elsif (exists $args{error}) {
        $f->fail( $args{error}->{message}, undef, $args{error} );
    }
    else {
        die 'Unhandled reply';
    }

    return;
}

sub _dispatch_stream {
    my $self = shift;
    my %args = @_;

    if (my $stream = $self->{_streams}->{$args{header}->{serial}}) {
        if ($args{error}) {
            return $stream->_dispatch_error($args{error});
        }
        else {
            return $stream->_dispatch_receive($args{data}, $args{final});
        }
    }
    else {
        return $self->{on_stream}->( @_ );
    }
}

sub configure {
    my $self = shift;
    my %args = @_;
    for my $key (keys %args) {
        $self->{$key} = $args{$key} // sub {};
    }
}

sub register {
    my $self = shift;
    my $r = shift;

    $r->configure(
        on_closed  => sub { $self->_dispatch_closed( @_ ) },
        on_message => sub { $self->_dispatch_message( @_ ) },
        on_reply   => sub { $self->_dispatch_reply( @_ ) },
        on_stream  => sub { $self->_dispatch_stream( @_ ) }
        );
    $self->{remote} = $r;
}


async sub _pump($conn, $transport) {
    my $eof;
    my $data;
    while (not $eof) {
        my ($len, $type) = $transport->need;
        $log->trace( "Reading data from connection: initiated (len: $len)" );
        ($data, $eof) = await $conn->read( $type, $len );
        $log->trace( 'Reading data from connection: completed' );

        await Future->wait_all( $transport->receive($data) );
        $log->trace( 'Processed input data from connection' );
    }
}

extended async sub connect($self, :$pump = undef) {
    unless ($self->{connection}) {
        my $factory =
            $self->{factory} //= Sys::Async::Virt::Connection::Factory->new;
        my $conn = $factory->create_connection( $self->{url} );
        $self->add_child( $conn );
        $self->{connection} = $conn;
    }

    unless ($self->{transport}) {
        my $conn      = $self->{connection};
        my $transport = Protocol::Sys::Virt::Transport->new(
            role => 'client',
            on_send => async sub($opaque, @data) {
                await $conn->write( @data );
                return $opaque;
            });
        $self->{transport} = $transport;
    }

    $self->{remote} //= Protocol::Sys::Virt::Remote->new( role => 'client' );
    $self->{remote}->register( $self->{transport} );
    $self->register( $self->{remote} );

    await $self->{connection}->connect;

    $pump //= \&_pump;
    $self->adopt_future( $pump->( $self->{connection}, $self->{transport} ) );
}


# ENTRYPOINT: REMOTE_PROC_CONNECT_DOMAIN_EVENT_CALLBACK_REGISTER_ANY
# ENTRYPOINT: REMOTE_PROC_CONNECT_DOMAIN_EVENT_CALLBACK_DEREGISTER_ANY
async sub domain_event_register_any($self, $eventID, $domain = undef) {
    my $rv = await $self->_call(
        $remote->PROC_CONNECT_DOMAIN_EVENT_CALLBACK_REGISTER_ANY,
        { eventID => $eventID, dom => $domain });
    my $dereg = $remote->PROC_CONNECT_DOMAIN_EVENT_CALLBACK_DEREGISTER_ANY;
    my $cb = Sys::Async::Virt::Callback->new(
        id => $rv->{callbackID},
        client => $self,
        deregister_call => $dereg,
        factory => sub { $self->loop->new_future }
        );
    $self->{_callbacks}->{$rv->{callbackID}} = $cb;
    weaken $self->{_callbacks}->{$rv->{callbackID}};

    return $cb;
}

# ENTRYPOINT: REMOTE_PROC_CONNECT_NETWORK_EVENT_REGISTER_ANY
# ENTRYPOINT: REMOTE_PROC_CONNECT_NETWORK_EVENT_DEREGISTER_ANY
async sub network_event_register_any($self, $eventID, $network = undef) {
    my $rv = await $self->_call(
        $remote->PROC_CONNECT_NETWORK_EVENT_REGISTER_ANY,
        { eventID => $eventID, net => $network });
    my $dereg = $remote->PROC_CONNECT_NETWORK_EVENT_DEREGISTER_ANY;
    my $cb = Sys::Async::Virt::Callback->new(
        id => $rv->{callbackID},
        client => $self,
        deregister_call => $dereg,
        factory => sub { $self->loop->new_future }
        );
    $self->{_callbacks}->{$rv->{callbackID}} = $cb;

    return $cb;
}

# ENTRYPOINT: REMOTE_PROC_CONNECT_STORAGE_POOL_EVENT_REGISTER_ANY
# ENTRYPOINT: REMOTE_PROC_CONNECT_STORAGE_POOL_EVENT_DEREGISTER_ANY
async sub storage_pool_event_register_any($self, $eventID, $pool = undef) {
    my $rv = await $self->_call(
        $remote->PROC_CONNECT_STORAGE_POOL_EVENT_REGISTER_ANY,
        { eventID => $eventID, pool => $pool });
    my $dereg = $remote->PROC_CONNECT_STORAGE_POOL_EVENT_DEREGISTER_ANY;
    my $cb = Sys::Async::Virt::Callback->new(
        id => $rv->{callbackID},
        client => $self,
        deregister_call => $dereg,
        factory => sub { $self->loop->new_future }
        );
    $self->{_callbacks}->{$rv->{callbackID}} = $cb;

    return $cb;
}

# ENTRYPOINT: REMOTE_PROC_CONNECT_NODE_DEVICE_EVENT_REGISTER_ANY
# ENTRYPOINT: REMOTE_PROC_CONNECT_NODE_DEVICE_EVENT_DEREGISTER_ANY
async sub node_device_event_register_any($self, $eventID, $dev = undef) {
    my $rv = await $self->_call(
        $remote->PROC_CONNECT_NODE_DEVICE_EVENT_REGISTER_ANY,
        { eventID => $eventID, dev => $dev });
    my $dereg = $remote->PROC_CONNECT_NODE_DEVICE_EVENT_DEREGISTER_ANY;
    my $cb = Sys::Async::Virt::Callback->new(
        id => $rv->{callbackID},
        client => $self,
        deregister_call => $dereg,
        factory => sub { $self->loop->new_future }
        );
    $self->{_callbacks}->{$rv->{callbackID}} = $cb;

    return $cb;
}

# ENTRYPOINT: REMOTE_PROC_CONNECT_SECRET_EVENT_REGISTER_ANY
# ENTRYPOINT: REMOTE_PROC_CONNECT_SECRET_EVENT_DEREGISTER_ANY
async sub secret_event_register_any($self, $eventID, $secret = undef) {
    my $rv = await $self->_call(
        $remote->PROC_CONNECT_SECRET_EVENT_REGISTER_ANY,
        { eventID => $eventID, secret => $secret });
    my $dereg = $remote->PROC_CONNECT_SECRET_EVENT_DEREGISTER_ANY;
    my $cb = Sys::Async::Virt::Callback->new(
        id => $rv->{callbackID},
        client => $self,
        deregister_call => $dereg,
        factory => sub { $self->loop->new_future }
        );
    $self->{_callbacks}->{$rv->{callbackID}} = $cb;

    return $cb;
}

# ENTRYPOINT: REMOTE_PROC_AUTH_LIST
# ENTRYPOINT: REMOTE_PROC_AUTH_POLKIT
# ENTRYPOINT: REMOTE_PROC_AUTH_SASL_INIT
async sub auth {
    my ($self, $auth_type) = @_;

    my $rv = await $self->_call( $remote->PROC_AUTH_LIST );
    my $auth_types = $rv->{types};
    my $selected = $remote->AUTH_NONE;
    for my $type ( @{ $auth_types } ) {
        if ($auth_type == $type) {
            $selected = $type;
            last;
        }
    }
    return if $selected == $remote->AUTH_NONE;

    if ($selected == $remote->AUTH_POLKIT) {
        await $self->_call( $remote->PROC_AUTH_POLKIT );
        return;
    }
    if ($selected == $remote->AUTH_SASL) {
        $rv = await $self->_call( $remote->PROC_AUTH_SASL_INIT );
        my $mechs = $rv->{mechlist};
        ...
    }
    return;
}


# ENTRYPOINT: REMOTE_PROC_CONNECT_OPEN
# ENTRYPOINT: REMOTE_PROC_CONNECT_REGISTER_CLOSE_CALLBACK
async sub open {
    my ($self, $url, $flags) = @_;
    await $self->_call( $remote->PROC_CONNECT_OPEN,
                        { name => $url, flags => $flags // 0 } );
    if (await $self->_supports_feature(
            $self->{remote}->DRV_FEATURE_REMOTE_CLOSE_CALLBACK )) {
        await $self->_call( $remote->PROC_CONNECT_REGISTER_CLOSE_CALLBACK );
    }
    if (not await $self->_supports_feature(
            $self->{remote}->DRV_FEATURE_REMOTE_EVENT_CALLBACK )) {
        die "Remote not supported: REMOTE_EVENT_CALLBACK feature not available";
    }
}

# ENTRYPOINT: REMOTE_PROC_CONNECT_CLOSE
# ENTRYPOINT: REMOTE_PROC_CONNECT_UNREGISTER_CLOSE_CALLBACK
async sub close {
    my ($self) = @_;
    for my $cb (values %{ $self->{_callbacks} }) {
        await $cb->cancel;
    }
    await $self->_call( $remote->PROC_CONNECT_UNREGISTER_CLOSE_CALLBACK );
    await $self->_call( $remote->PROC_CONNECT_CLOSE, {} );
}


__CALLS__

1;

__END__

=head1 NAME

Sys::Async::Virt - LibVirt protocol implementation for clients

=head1 VERSION

__VERSION__

Based on LibVirt tag __LIBVIRT_TAG__

=head1 SYNOPSIS

  use IO::Async::Loop;
  use Sys::Async::Virt;

  my $loop = IO::Async::Loop->new;
  my $client = Sys::Async::Virt->new(url => 'qemu:///system');

  $loop->add( $client );
  await $client->connect;
  await $client->auth( $remote->AUTH_NONE );
  await $client->open( 'qemu:///system' );


=head1 DESCRIPTION

This module manages access to a LibVirt service through its remote protocol.

The API documentation of this module and the related modules
C<Sys::Async::Virt::*> is meant to be used in conjunction with the
documentation found at L<LibVirt's API
reference|https://libvirt.org/html/index.html>.  Since the C API is procedural
whereas the Perl API is object oriented, the mapping of API entry points isn't
one-to-one.  Each entry point links to its C API equivalent on the libvirt.org
site, enabling users to quickly find documentation.  (Please report any
broken links.)

An important difference with the C API is that this API only lists the
C<INPUT> and C<INPUT|OUTPUT (as input)> arguments for its functions.  The
C<OUTPUT> and C<INPUT|OUTPUT (as output)> arguments will be returned in the
C<on_reply> event.

=head2 STABILITY GUARANTEES

The modules in this distribution are considered B<experimental>, meaning that
no interface guarantees are made at this time.  However, since the protocol
description from which most of the code is generated, changes are anticipated
to be minimal.  The more feedback the project receives, the sooner the project
will be able to commit to the API as it is.

=head2 ASYNCHRONOUS INVOCATIONS

The API calls in these modules invoke remote procedure calls (RPC) on a
LibVirt server (which may run locally). The return values are L<Future>s
which can be C<await>ed using L<Future::AsyncAwait>.  Many calls start a
process on the server without awaiting the result.  One example is the
C<$domain->shutdown()> invocation: it returns when shut down has been
initiated, not when the domain is actually shut off. Other calls query
the server for state (such as C<$domain->get_state()>) and return the
state when the server replies to the invocation.

The LibVirt protocol and server support concurrent requests: requests
issued before earlier requests have finished. The server responds as soon
as the result is available. This means that server replies may come back
out-of-order, resolving futures as results become available. The use of
C<async> and C<await> help to await results from the server and continue
processing as soon as results become available.

=head1 CLIENT EVENTS

=head2 on_message

  $on_message->( @@@TODO );

Receives all messages which either don't classify as a callback invocation
(i.e. the return value structure doesn't have a C<callbackID> member), or
for which no callback has been registered through one of the callback
registration functions.

=head2 on_stream

  $on_stream->( @@@TODO );

Receives all messages for which no stream has been instantiated and returned
through the relevant API calls.


=head2 on_close

  $on_close->();

=head1 LIBVIRT EVENTS

=head2 domain_event_register_any

  $cb = await $client->domain_event_register_any( $event_id, $dom = undef );

Subscribes to events of type C<$event_id>. Restricts events to a specific
domain by passing a value into C<$dom>.

Returns a L<Sys::Async::Virt::Callback> instance.

=head2 network_event_register_any

  $cb = await $client->network_event_register_any( $event_id, $net = undef );

Subscribes to events of type C<$event_id>. Restricts events to a specific
network by passing a value into C<$net>.

Returns a L<Sys::Async::Virt::Callback> instance.

=head2 node_device_event_register_any

  $cb = await $client->node_device_event_register_any( $event_id, $dev = undef );

Subscribes to events of type C<$event_id>. Restricts events to a specific
device by passing a value into C<$dev>.

Returns a L<Sys::Async::Virt::Callback> instance.

=head2 secret_event_register_any

  $cb = await $client->secret_event_register_any( $event_id, $secret = undef);

Subscribes to events of type C<$event_id>. Restricts events to a specific
secret by passing a value into C<$secret>.

Returns a L<Sys::Async::Virt::Callback> instance.

=head2 storage_pool_event_register_any

  $cb = await $client->storage_pool_event_register_any( $event_id, $pool = undef );

Subscribes to events of type C<$event_id>. Restricts events to a specific
storage pool by passing a value into C<$pool>.

Returns a L<Sys::Async::Virt::Callback> instance.

=head1 CONSTRUCTOR

=head2 new

  $client = Sys::Async::Virt->new( remote => $remote, ... );

Creates a new client instance.  The constructor supports these parameters:

=over 8

=item * C<factory> (optional)

=item * C<connection> (optional)

=item * C<transport> (optional)

=item * C<remote> (optional)

=item * C<keepalive> (optional)

=item * C<url> (optional)

=item * C<on_stream> (optional)

=back

=head1 METHODS

=head2 configure

=head2 register

  $client->register( $remote );

=head2 connect

  await $client->connect( $url );

Sets up the transport connection to the server indicated by C<url>.

=head2 auth

  await $client->auth( $auth_type );
  # -> (* no data *)

Authenticates against the server.

=head2 open

  await $client->open( $url, $flags = 0 );
  # -> (* no data *)

This function opens the connection to the remote driver C<$url> as documented in
L<LibVirt's Connection URIs|https://libvirt.org/uri.html>.  Note that the value
is to be the B<local> hypervisor URI as applicable to the remote end of the
connection.

=head2 close

  await $client->close;
  # -> (* no data *)

Announces to the remote the intent to close the connection. The client will
receive a confirmation message from the server after which the server will
close the connection.

__ENTRYPOINTS__

=head1 CONSTANTS

=over 8

__CONSTANTS_POD__

=back

=head1 INTERNAL METHODS

=head2 _call

This method forwards protocol "calls" to the C<remote> instance.  Using this
wrapper allows for tracking all calls allowing to set up handling of the
replies.

=head2 _send

=head2 _send_end

=head2 _dispatch_message

=head2 _dispatch_reply

=head2 _dispatch_stream

__PRIVATE_EPS__

=head1 BUGS AND LIMITATIONS

=over 8

=item * Talking to servers without the REMOTE_EVENT_CALLBACK feature (v1.3.3)
  is not - currently - supported

=begin fill-templates

# ENTRYPOINT: REMOTE_PROC_CONNECT_DOMAIN_EVENT_DEREGISTER
# ENTRYPOINT: REMOTE_PROC_CONNECT_DOMAIN_EVENT_DEREGISTER_ANY
# ENTRYPOINT: REMOTE_PROC_CONNECT_DOMAIN_EVENT_REGISTER
# ENTRYPOINT: REMOTE_PROC_CONNECT_DOMAIN_EVENT_REGISTER_ANY

=end fill-templates

=back

=head2 TODO

=over 8

=item * Update the cached proxy instances (e.g. domains) after creation
to include 'id' (e.g. domain 'id')

Although this doesn't seem a prerequisite for the API to work correctly,
it seems sloppy that there's no update of the domain 'id' when one becomes
available when the domain is started. (Looking at the sources of LibVirt,
the 'id' doesn't get cleared when the domain is destroyed???)

=item * KeepAlive support

=item * Modules implementing connections for various protocols (unix, tcp, tls, etc)

=item * C<@generate: none> entrypoints review (and implement relevant ones)

=item * C<@generate: server> entrypoints review (and implement relevant ones)

=back

=head2 UNIMPLEMENTED ENTRYPOINTS

The following entrypoints have not been implemented yet; contributions
towards implementation are greatly appreciated.

=over 8

__UNIMPLEMENTED__

=back

=head1 SEE ALSO

L<LibVirt|https://libvirt.org>, L<Sys::Virt>

=head1 LICENSE AND COPYRIGHT

  Copyright (C) 2024 Erik Huelsmann

All rights reserved. This program is free software;
you can redistribute it and/or modify it under the same terms as Perl itself.
