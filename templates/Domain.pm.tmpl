####################################################################
#
#     This file was generated using XDR::Parse version __XDR_PARSE_VERSION__
#                   and LibVirt version __LIBVIRT_TAG__
#
#      Don't edit this file, use the source template instead
#
#                 ANY CHANGES HERE WILL BE LOST !
#
####################################################################


use v5.26;
use warnings;
use experimental 'signatures';
use Feature::Compat::Try;
use Future::AsyncAwait;
use Object::Pad 0.821;
use Sublike::Extended 0.29 'method', 'sub'; # From XS-Parse-Sublike, used by Future::AsyncAwait

class Sys::Async::Virt::Domain __VERSION__;

use Carp qw(croak);
use Log::Any qw($log);

use Protocol::Sys::Virt::TypedParams __P::S::V::VERSION__;
use Protocol::Sys::Virt::Remote::XDR __P::S::V::VERSION__;
my $remote = 'Protocol::Sys::Virt::Remote::XDR';

__CONSTANTS__

field $_rpc_id :param :reader;
field $_client :param :reader;

method id() {
    return $_rpc_id->{id};
}

method name() {
    return $_rpc_id->{name};
}

method uuid() {
    return $_rpc_id->{uuid};
}

method uuid_string() {
    return join( '-', unpack('H8H4H4H4H12', $_rpc_id->{uuid}) );
}

# ENTRYPOINT: REMOTE_PROC_DOMAIN_GET_BLOCK_JOB_INFO
async method get_block_job_info($disk, $flags = 0) {
    my $rv = await $_client->_call(
        $remote->PROC_DOMAIN_GET_BLOCK_JOB_INFO,
        { dom => $_rpc_id, path => $disk, flags => $flags // 0 } );

    if ($rv->{found}) {
        return $rv;
    }
    else {
        return undef;
    }
}

# ENTRYPOINT: REMOTE_PROC_DOMAIN_GET_EMULATOR_PIN_INFO
async method get_emulator_pin_info($flags = 0) {
    my $maplen = await $_client->_maplen;
    my $rv = await $_client->_call(
        $remote->PROC_DOMAIN_GET_EMULATOR_PIN_INFO,
        { dom => $_rpc_id, maplen => $maplen,
          flags => $flags // 0 } );

    if ($rv->{ret} == 0) {
        return undef;
    }
    else {
        return await $_client->_from_cpumap( $rv->{cpumaps} );
    }
}

# ENTRYPOINT: REMOTE_PROC_DOMAIN_GET_IOTHREAD_INFO
async method get_iothread_info($flags = 0) {
    my $rv = await $_client->_call(
        $remote->PROC_DOMAIN_GET_IOTHREAD_INFO,
        { dom => $_rpc_id, flags => $flags // 0 } );

    my @rv;
    for my $thread ($rv->{info}->@*) {
        push @rv, {
            iothread_id => $thread->{iothread_id},
            cpumap => await $_client->_from_cpumap( $thread->{cpumap} )
        };
    }

    return \@rv;
}

sub _patch_security_label($sec) {
    my $label = $sec->{label};
    $label = join('', map { chr($_) } $label->@* );
    chop $label; # eliminate terminating ascii \0-char
    $sec->{label} = $label;
}

# ENTRYPOINT: REMOTE_PROC_DOMAIN_GET_SECURITY_LABEL
async method get_security_label() {
    my $rv = await $_client->_call(
        $remote->PROC_DOMAIN_GET_SECURITY_LABEL,
        { dom => $_rpc_id } );

    _patch_security_label( $rv );
    return $rv;
}

# ENTRYPOINT: REMOTE_PROC_DOMAIN_GET_SECURITY_LABEL_LIST
async method get_security_label_list() {
    my $rv = await $_client->_call(
        $remote->PROC_DOMAIN_GET_SECURITY_LABEL_LIST,
        { dom => $_rpc_id } );

    for my $label ($rv->{labels}->@*) {
        _patch_security_label( $label );
    }

    return $rv->{labels};
}

# ENTRYPOINT: REMOTE_PROC_DOMAIN_GET_TIME
async method get_time($flags = 0) {
    my $rv = await $_client->_call(
        $remote->PROC_DOMAIN_GET_TIME,
        { dom => $_rpc_id, flags => $flags // 0 } );

    return ( $rv->{seconds}, $rv->{nseconds} );
}

# ENTRYPOINT: REMOTE_PROC_DOMAIN_GET_VCPU_PIN_INFO
async method get_vcpu_pin_info($flags = 0) {
    my $vcpus  = await $self->get_vcpus_flags( $flags // 0 );
    my $cpus   = await $_client->{totcpus};
    my $maplen = await $_client->_maplen;
    my $rv = await $_client->_call(
        $remote->PROC_DOMAIN_GET_VCPU_PIN_INFO,
        { dom => $_rpc_id, ncpumaps => $vcpus,
          maplen => $maplen, flags => $flags });

    my $maps = $rv->{cpumaps};
    my @rv;
    foreach my $vcpu_idx (0 .. ($rv->{num} - 1)) {
        push @rv, await $_client->_from_cpumap( $vcpu_idx*$maplen );
    }

    return \@rv;
}

# ENTRYPOINT: REMOTE_PROC_DOMAIN_GET_VCPUS
async method get_vcpus() {
    my $vcpus  = await $self->get_vcpus_flags;
    my $maplen = await $_client->_maplen;
    my $rv = await $_client->_call(
        $remote->PROC_DOMAIN_GET_VCPUS,
        { dom => $_rpc_id, maxinfo => $vcpus, maplen => $maplen } );

    my @rv;
    foreach my $vcpu_idx (0 .. ($vcpus - 1)) {
        push @rv, {
            $rv->{info}->[$vcpu_idx]->%*,
            affinity => await $_client->_from_cpumap( $rv->{cpumaps},
                                                     $vcpu_idx*$maplen ) };
    }

    return \@rv;
}


###############################################################################
#
#                                MIGRATION CODE
#
###############################################################################
#
# The migration protocol is documented in libvirt's repository:
#   https://gitlab.com/libvirt/libvirt/-/blob/master/docs/kbase/internals/migration.rst
#



# ENTRYPOINT: REMOTE_PROC_DOMAIN_MIGRATE_BEGIN3_PARAMS
# ENTRYPOINT: REMOTE_PROC_DOMAIN_MIGRATE_PREPARE3_PARAMS
# ENTRYPOINT: REMOTE_PROC_DOMAIN_MIGRATE_PERFORM3_PARAMS
# ENTRYPOINT: REMOTE_PROC_DOMAIN_MIGRATE_CONFIRM3_PARAMS
# ENTRYPOINT: REMOTE_PROC_DOMAIN_MIGRATE_FINISH3_PARAMS
async method migrate($dest_client, $params, $flags) {
    #
    # This function is a port of virDomainMigrate3
    #
    my $cancelled     = 1;
    my $cookie;
    my $notify_source = 1;
    my $saved_error;

    die $log->error(q{migrate() flags MIGRATE_NON_SHARED_DISK and }
                    . q{MIGRATE_NON_SHARED_INC are mutually exclusive.})
        if ($flags & MIGRATE_NON_SHARED_DISK
            and $flags & MIGRATE_NON_SHARED_INC);

    die $log->error(q{migrate() flag MIGRATE_NON_SHARED_SYNCHRONOUS_WRITES }
                    . q{requires either MIGRATE_NON_SHARED_DISK or }
                    . q{MIGRATE_NON_SHARED_INC.})
        if ($flags & MIGRATE_NON_SHARED_SYNCHRONOUS_WRITES
            and not ($flags & (MIGRATE_NON_SHARED_DISK | MIGRATE_NON_SHARED_INC)));

    die $log->error(q{migrate() with 'dest_client' does not support PEER2PEER and/or TUNNELLED flags})
        if ($flags & MIGRATE_PEER2PEER or $flags & MIGRATE_TUNNELLED);

    typed_params_field( $params, MIGRATE_PARAM_DEST_NAME )
        or typed_params_field( $params, MIGRATE_PARAM_DEST_NAME,
                               typed_value_new( TYPED_PARAM_STRING, $self->name ) );

    # The original code contains the section below, but we set the destination name here instead
    # die $log->error(q{migrate() requires a non-zero-length destination VM name})
    #     unless typed_params_field_string_value( $params, MIGRATE_PARAM_DEST_NAME );

    my $params_feature = $dest_client->remote->DRV_FEATURE_MIGRATION_PARAMS;
    die $log->error(q{Destination host missing feature MIGRATION_PARAMS; }
                    . q{older migration protocols not supported})
        if (not await $dest_client->_supports_feature( $params_feature ));

    if ($flags & MIGRATE_OFFLINE) {
        my $offline_feature = $_client->remote->DRV_FEATURE_MIGRATION_OFFLINE;
        die $log->error(q{Source host does not support offline migration})
            if (await $_client->_supports_feature( $offline_feature ));
        die $log->error(q{Destination host does not support offline migration})
            if (await $dest_client->_supports_feature( $offline_feature ));
    }


    my $protection = 0;
    my $protection_feature = $_client->remote->DRV_FEATURE_MIGRATE_CHANGE_PROTECTION;
    if (await $_client->_supports_feature( $protection_feature )) {
        $protection = MIGRATE_CHANGE_PROTECTION;
    }
    if ($flags & MIGRATE_CHANGE_PROTECTION and not $protection) {
        die $log->error(q{Cannot enforce change protection});
    }
    $flags &= ~MIGRATE_CHANGE_PROTECTION;


    # Require VIR_DRV_FEATURE_MIGRATION_PARAMS to be available,
    # since it was available since 2013
    die $log->error(q{Source host does not support VIR_DRV_FEATURE_MIGRATION_PARAMS})
        unless await $_client->_supports_feature( $_client->remote->DRV_FEATURE_MIGRATION_PARAMS );
    die $log->error(q{Destination host does not support VIR_DRV_FEATURE_MIGRATION_PARAMS})
        unless await $dest_client->_supports_feature( $_client->remote->DRV_FEATURE_MIGRATION_PARAMS );


    my $rv;
    $rv = await $_client->_call(
        $remote->PROC_DOMAIN_MIGRATE_BEGIN3_PARAMS,
        { dom => $_rpc_id, params => $params,
          flags => ($flags | $protection) });

    my $dom_xml;
    ($dom_xml, $cookie) = $rv->@{ qw( xml cookie_out ) };
    return undef unless $dom_xml;

    try {
        $rv = await $self->get_state;
        if ($rv->{'state'} == PAUSED
            and not ($flags & MIGRATE_POSTCOPY_RESUME)) {
            $flags |= MIGRATE_PAUSED;
        }
    }
    catch ($e) {
        $log->debug( "Error: $e" );
        # ignore errors
    }

    my $dest_uri;
    my $dest_flags = $flags & ~(MIGRATE_ABORT_ON_ERROR | MIGRATE_AUTO_CONVERGE);


    # # replace the MIGRATE_PARAM_DEST_XML parameter with $dom_xml
    $params = typed_params_new( $params );
    typed_params_field( $params, MIGRATE_PARAM_DEST_XML,
                        typed_value_new( TYPED_PARAM_STRING, $dom_xml ) );
    try {
        $rv = await $dest_client->_call(
            $remote->PROC_DOMAIN_MIGRATE_PREPARE3_PARAMS,
            { cookie_in => $cookie, params => $params, flags => $dest_flags });
        ($cookie, $dest_uri) = $rv->@{ qw( cookie_out uri_out ) };
    }
    catch ($e) {
        $log->debug( "Error: $e" );
        if ($protection) {
            $saved_error = $e;
            goto confirm;
        }
        else {
            goto done;
        }
    }
    if ($dest_uri) {
        typed_params_field( $params, MIGRATE_PARAM_URI,
                            typed_value_new( TYPED_PARAM_STRING, $dest_uri ) );
    }
    elsif (not typed_params_field_string_value( $params, MIGRATE_PARAM_URI )) {
        try {
            die $log->error("Internal error: MIGRATE_PREPARE3 didn't set 'uri'");
        }
        catch ($e) {
            $log->debug( "Error: $e" );
            $saved_error = $e;
            goto finish;
        }
    }

    if ($flags & MIGRATE_OFFLINE) {
        $log->debug("Offline migration, skipping Perform phase");

        $cookie = undef;
        $cancelled = 0;
        goto finish;
    }

    $log->debug("Perform3");
    try {
        $rv = await $_client->_call(
            $remote->PROC_DOMAIN_MIGRATE_PERFORM3_PARAMS,
            { dom => $_rpc_id,
              dconnuri => undef,
              params => $params,
              cookie_in => $cookie,
              flags => ($flags | $protection),
            } );
        $cookie = $rv->{cookie_out};
        $cancelled = 0;
    }
    catch ($e) {
        $log->debug( "Error: $e" );
        $saved_error   = $e;
        $notify_source = 0;
    }

  finish:
    my $ddomain;
    try {
        $rv = await $dest_client->_call(
            $remote->PROC_DOMAIN_MIGRATE_FINISH3_PARAMS,
            { params => $params, cookie_in => $cookie,
              flags => $dest_flags, cancelled => $cancelled });
        ( $ddomain, $cookie ) = $rv->@{ qw( dom cookie_out ) };
    }
    catch ($e) {
        $log->debug( "Error: $e" );
        # ignore errors
    }

    if ($cancelled and $ddomain) {
        $log->error("finish step ignored migration cancellation and started domain");
    }
    $cancelled = not defined $ddomain;

  confirm:

    if ($notify_source) {
        try {
            await $_client->_call(
                $remote->PROC_DOMAIN_MIGRATE_CONFIRM3_PARAMS,
                { dom => $_rpc_id, params => $params, cookie_in => $cookie,
                  flags => ($flags | $protection), cancelled => $cancelled});
        }
        catch ($e) {
            $log->debug( "Error: $e" );

            my $name = $self->name;
            $log->warn("Guest '$name' probably left in 'paused' state on source");
        }
    }

  done:
    if ($saved_error) {
        die $saved_error;
    }
    else {
        return $ddomain;
    }
}

async method _managed_p2p_migrate($dest_libvirt_uri, $params, $flags) {
    die $log->error(q{migrate() without PEER2PEER flag should not pass 'dest_libvirt_uri'})
        if ($flags & MIGRATE_PEER2PEER);


}

async method _unmanaged_direct_migrate($params, $flags) {
    die $log->error(q{migrate() requires MIGRATE_PARAM_URI when called without both 'dest_client' and 'dest_client_uri'})
        if (not typed_params_field_string_value( $params, MIGRATE_PARAM_URI ));
}


###############################################################################
#
#                             END OF MIGRATION CODE
#
###############################################################################


# ENTRYPOINT: REMOTE_PROC_DOMAIN_PIN_EMULATOR
async method pin_emulator($cpumap, $flags = 0) {
    await $self->_call(
        $remote->PROC_DOMAIN_PIN_EMULATOR,
        { dom => $_rpc_id, cpumap => $cpumap,
          flags => $flags // 0 } );
}

__CALLS__


1;


__END__

=head1 NAME

Sys::Async::Virt::Domain - Client side proxy to remote LibVirt domain

=head1 VERSION

__VERSION__

=head1 SYNOPSIS

  use Future::AsyncAwait;

  my $dom = await $virt->lookup_domain_by_name( 'domain' );
  await $dom->create;        # -> start domain
  say await $dom->get_state; # "1" ("running")
  await $dom->shutdown;      # -> gracefully shut down domain
  say await $dom->get_state; # "4" ("shutting down")

=head1 DESCRIPTION

Provides access to a domain and its related resources on the server.
The domain may or may not be running.

=head1 EVENTS

Event callbacks can be acquired through
L<Sys::Async::Virt/domain_event_register_any>.

=head1 CONSTRUCTOR

=head2 new

Not to be called directly. Instances are returned from calls
in L<Sys::Async::Virt>.

=head1 METHODS

=head2 id

  $id = $dom->id;

Returns the id of the domain when running or C<undef> otherwise.

=head2 name

  $name = $dom->name;

Returns the name of the domain.

=head2 uuid

  $uuid = $dom->uuid;

Returns a 16-byte string containing the (binary) UUID.

=head2 uuid_string

  $str = $dom->uuid_string;

Returns the string representation of the UUID (C<xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx>).

=head2 get_block_job_info

  $job_info = await $dom->get_block_job_info( $disk );

Returns undef when no job associated with the named block device was found;
otherwise returns a reference to a hash with the fields as documented in the
L<virDomainBlockJobInfo|https://libvirt.org/html/libvirt-libvirt-domain.html#virDomainBlockJobInfo>
structure.

See also documentation of L<virDomainGetBlockJobInfo|https://libvirt.org/html/libvirt-libvirt-domain.html#virDomainGetBlockJobInfo>.

=head2 get_emulator_pin_info

  $pins = await $dom->get_emulator_pin_info( $flags );

Returns an array reference with elements being booleans indicating pinning of
the emulator threads to the associated CPU, or C<undef> in case no emulator
threads are pinned.

See also the documentation of L<virDomainGetEmulatorPinInfo|https://libvirt.org/html/libvirt-libvirt-domain.html#virDomainGetEmulatorPinInfo>.

=head2 get_iothread_info

  $iothreads = await $dom->get_iothread_info;

Returns an array of hashes. Each hash has the keys C<iothread_id> and
C<cpumap>. The CPU map is returned as an array of boolean values.

See also documentation of L<virDomainGetIOThreadInfo|https://libvirt.org/html/libvirt-libvirt-domain.html#virDomainGetIOThreadInfo>.

=head2 get_perf_events

  $perf_events = await $dom->get_perf_events;

Returns an array reference where each element in the array is a
L<typed parameter value|Sys::Async::Virt/Typed parameter values>.

=head2 get_time

  ($secs, $nanos) = await $dom->get_time;

Return time extracted from the domain.

See also the documentation of L<virDomainGetTime|https://libvirt.org/html/libvirt-libvirt-domain.html#virDomainGetTime>.

=head2 get_vcpu_pin_info

  $vcpu_pins = await $dom->get_vcpu_pin_info( $flags = 0 );

Returns a reference to an array holding one entry for each vCPU. Each entry is
a reference to an array holding a boolean value for each physical CPU. The
boolean indicates whether the vCPU is allowed to run on that physical CPU
(affinity).

See also the documentation of L<virDomainGetVcpuPinInfo|https://libvirt.org/html/libvirt-libvirt-domain.html#virDomainGetVcpuPinInfo>.

=head2 get_vcpus

  $vcpus = await $dom->get_vcpus;

Returns a reference to an array holding one entry for each vCPU. Each entry is
a reference to a hash with the keys as described in
L<virVcpuInfo|https://libvirt.org/html/libvirt-libvirt-domain.html#virVcpuInfo>,
with one extra key C<affinity>, an array of booleans where each element
indicates whether the vCPU is allowed to run on that physical CPU (affinity).

See also the documentation of L<virDomainGetVcpus|https://libvirt.org/html/libvirt-libvirt-domain.html#virDomainGetVcpus>.

=head2 migrate

  my $ddom = await $dom->migrate( dest_client => $dest_client, params => $params, flags => $flags );

This function currently supports managed direct migration. See L<virDomainMigrate3|https://libvirt.org/html/libvirt-libvirt-domain.html#virDomainMigrate3>.

The functionality provided by L<virDomainMigrateToURI3|https://libvirt.org/html/libvirt-libvirt-domain.html#virDomainMigrateToURI3> is being developed.

=head2 pin_emulator

  await $dom->pin_emulator( $cpumap, $flags )
  # -> (* no data *)

Sets emulator threads to those indicated in C<$cpumap> -- a reference to an array
with boolean values, indicating a true value for each CPU the emulator is allowed
to be scheduled on.

See also the documentation of L<virDomainPinEmulator|https://libvirt.org/html/libvirt-libvirt-domain.html#virDomainPinEmulator>.

__ENTRYPOINTS__

=head1 INTERNAL METHODS

__PRIVATE_EPS__

=head1 CONSTANTS


__CONSTANTS_POD_PREAMBLE__


=over 8

__CONSTANTS_POD__

=back

=head1 BUGS AND LIMITATIONS

=head2 Unimplemented entry points

The following entry points have intentionally not been implemented,
because they are deprecated or contain bugs.

=over 8

=item * REMOTE_PROC_DOMAIN_CREATE (virDomainCreate)

This entry point contains a bug in the protocol definition; use
L</domain_create_flags> without flags (i.e. C<< $dom->domain_create_flags; >>)
to achieve the same effect.

=back

=begin fill-templates

# ENTRYPOINT: REMOTE_PROC_DOMAIN_CREATE

=end fill-templates

=head1 SEE ALSO

L<LibVirt|https://libvirt.org>, L<Sys::Virt>

=head1 LICENSE AND COPYRIGHT


  Copyright (C) 2024-2026 Erik Huelsmann

All rights reserved. This program is free software;
you can redistribute it and/or modify it under the same terms as Perl itself.
