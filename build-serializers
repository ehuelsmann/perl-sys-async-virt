#!/usr/bin/env perl

use v5.20;
use warnings FATAL => 'uninitialized';
use experimental 'signatures';

use JSON::PP;
use List::Util qw(max pairfirst);
use Scalar::Util qw(reftype);

use Protocol::Sys::Virt::Devel qw(extract_all);

my $source = '';
my @constants;
my @enums;
my @serializers;
my @deserializers;

my $json            = JSON::PP->new->canonical(1);
my $tag             = $ARGV[0];
my $version         = $ARGV[1];
my $dep_psv_version = $ARGV[2];


sub contents {
    my ($fn) = @_;
    local $/;
    open my $fh, '<:encoding(UTF-8)', $fn;
    <$fh>;
}

sub find_toplevel_definition {
    my ($ast, $name) = @_;
    for my $def (@{ $ast } ) {
        next if $def->{def} eq 'passthrough';
        next if $def->{def} eq 'preprocessor';

        return $def
            if $def->{name}->{content} eq $name;
    }
    return;
}

my %module = (
    remote_nonnull_domain => 'Domain',
    remote_nonnull_domain_checkpoint => 'DomainCheckpoint',
    remote_nonnull_domain_snapshot => 'DomainSnapshot',
    remote_nonnull_network => 'Network',
    remote_nonnull_network_port => 'NetworkPort',
    remote_nonnull_nwfilter => 'NwFilter',
    remote_nonnull_nwfilter_binding => 'NwFilterBinding',
    remote_nonnull_interface => 'Interface',
    remote_nonnull_storage_pool => 'StoragePool',
    remote_nonnull_storage_vol => 'StorageVol',
    remote_nonnull_node_device => 'NodeDevice',
    remote_nonnull_secret => 'Secret',
    );

my $main_module = 'Client';

my %prefix_strip_xdr = (
    Client => qr/^connect_/,
    Domain => qr/^domain_/,
    DomainCheckpoint => qr/^domain_(checkpoint_)?/,
    DomainSnapshot => qr/^domain_(snapshot_)?/,
    Network => qr/^network_/,
    NetworkPort => qr/^network_port_/,
    NwFilter => qr/^nwfilter_/,
    NwFilterBinding => qr/^nwfilter_binding_/,
    Interface => qr/^interface_/,
    StoragePool => qr/^storage_(pool_)?/,
    StorageVol => qr/^storage_(vol_)?/,
    NodeDevice => qr/^node_device_/,
    Secret => qr/^secret_/,
    );



sub _named_type_name {
    my $type = shift;
    if ($type->{spec} eq 'named') {
        return $type->{name}->{content};
    }
    return undef;
}

sub _retvals {
    my ($struct) = @_;
    return (
        map { +{ name => $_->{name}->{content},
                 type => _named_type_name( $_->{declaration}->{type} ) } }
        @{ $struct ? $struct->{definition}->{type}->{declaration}->{members} : [] }
        );
}

sub _retval_mapper {
    my ($ast, @retvals) = @_;

    my %mapped_retvals;
    for my $retval (@retvals) {
        if ($retval->{type}
            and $module{$retval->{type}}) {
            $mapped_retvals{$retval->{name}} = $retval->{type};
        }
        elsif ($retval->{type}
               and $retval->{type} =~ m/_msg$/
               and my $nested_msgstruct = find_toplevel_definition($ast, $retval->{type})) {
            my %submap = _retval_mapper($ast, $nested_msgstruct);
            $mapped_retvals{$retval->{name}} = \%submap if %submap;
        }
    }

    return %mapped_retvals;
}

sub _retval_map {
    my $map = shift;
    my @rv = ();
    for my $key ( sort keys %{ $map } ) {
        if (ref $map->{$key} and reftype $map->{$key} eq 'HASH') {
            push @rv, "$key => " . _retval_map( $map->{$key} );
        }
        else {
            push @rv, "$key => \\&_translate_$map->{$key}";
        }
    }

    return '{ ' . join(', ', @rv) . ' }';
}

sub _version_replacements {
    my $xdr_parse_version = shift // '';
    $_[0] =~ s/__XDR_PARSE_VERSION__/$xdr_parse_version/g;
    $_[0] =~ s/__P::S::V::VERSION__/$dep_psv_version/g;
    $_[0] =~ s/__VERSION__/$version/g;
}

my %varname = (
    Client => 'client',
    Domain => 'dom',
    DomainCheckpoint => 'checkpoint',
    DomainSnapshot => 'snapshot',
    Network => 'net',
    NetworkPort => 'port',
    NwFilter => 'filter',
    NwFilterBinding => 'binding',
    Interface => 'iface',
    StoragePool => 'pool',
    StorageVol => 'vol',
    NodeDevice => 'dev',
    Secret => 'secret',
    );

sub expand_mod_template($template, $mod, $h_syms, $module_functions, $translators, $xdr_parse_version) {
    my $tmpl = contents( $template . $mod . '.pm.tmpl' );
    my $calls = join("\n",
                     map { $_->{code} }
                     sort { $a->{name} cmp $b->{name} }
                     @{ $module_functions->{$mod} });
    my $entrypoints_pod = join("\n",
                               map {
                                   my $argstr = $_->{argstr} ? "( $_->{argstr} )" : '';
                                   $argstr =~ s/\$flags \)/\$flags = 0 \)/;
                                   my $retstr = ($_->{retstr} =~ s/{\s*}/(* no data *)/r);
                                   (not $_->{ret_unwrap}) ? <<~POD1 : <<~POD2;
                                   =head2 $_->{name}

                                     await \$$varname{$mod}->$_->{name}$argstr;
                                     # -> $retstr
                                   POD1
                                   =head2 $_->{name}

                                     \$$_->{ret_unwrap} = await \$$varname{$mod}->$_->{name}$argstr;
                                   POD2
                               }
                               sort { $a->{name} cmp $b->{name} }
                               @{ $module_functions->{$mod} });
    my @constants = grep { $_->{mod} eq $mod } @{ $h_syms };
    my $max = max map { length $_->{sym} } @constants;
    my $constants = join("\n    ",
                         map {
                             sprintf("%-${max}s => %s,", $_->{sym}, $_->{resolved})
                         } @constants);
    $constants = <<~CONSTANTS if $constants;
    use constant {
        $constants
    };
    CONSTANTS

    my $constants_pod = join("\n\n=item ", map { $_->{sym} } @constants);
    _version_replacements( $xdr_parse_version, $tmpl );
    $tmpl =~ s/__REPLY_TRANSLATORS__/$translators/;
    $tmpl =~ s/__CALLS__/$calls/;
    $tmpl =~ s/__CONSTANTS__/$constants/;
    $tmpl =~ s/__ENTRYPOINTS__/$entrypoints_pod/;
    $tmpl =~ s/__CONSTANTS_POD__/$constants_pod/;

    my $out = ($mod ne $main_module) ?
        "lib/Sys/Async/Virt/$mod.pm" : 'lib/Sys/Async/Virt.pm';
    open my $fh, '>', $out
        or die "$!";
    print $fh $tmpl;
}

sub proc_msg($proc_annotation, $module_returns, $msgstruct, $ast, $proc_value) {
    if ($proc_annotation !~ m/\@generate: (both|client)/) {
        return;
    }
    my @retvals = _retvals( $msgstruct );
    my %mapped_retvals = _retval_mapper($ast, @retvals);
    my $ret_unwrap = (@retvals == 1 ? $retvals[0]->{name} : '');
    if (%mapped_retvals or $ret_unwrap) {
        my $mapstr = _retval_map( \%mapped_retvals );
        $ret_unwrap = $ret_unwrap ? "'$ret_unwrap'" : 'undef';
        $module_returns->[$proc_value] =
            qq|sub { $proc_value; my \$client = shift; _translated(\$client, $ret_unwrap, $mapstr, \@_) }|;
    }
    else {
        $module_returns->[$proc_value] = '\&_no_translation';
    }
}

sub proc_call($ast, $module_functions, $module_returns, $proc_value, $proc_const, $struct_basename) {
    my $func = ($struct_basename =~ s/^remote_//r);
    my $callstruct_name = $struct_basename . '_args';
    my $retstruct_name = $struct_basename . '_ret';
    my $callstruct = find_toplevel_definition($ast, $callstruct_name);
    my $retstruct = find_toplevel_definition($ast, $retstruct_name);
    my $into_module = $main_module;

    my @callargs = _retvals( $callstruct );
    my @retvals  = _retvals( $retstruct );

    my $first_call_arg = @callargs ? $callargs[0] : undef;
    if ($first_call_arg) {
        my $first_arg_type_name = $first_call_arg->{type} // '__unmapped__';
        $into_module = $module{$first_arg_type_name} // $main_module;
    }

    # gendispatch.pl says 'node_device' is special
    if ($func =~ m/^node_device_/
        and $func !~ m/^node_device_(lookup_(by_name|scsi_host_by_wwn)_|(create|define)_xml_)/) {
        $into_module = $module{remote_nonnull_node_device};
    }

    my $entrypoint = ($func =~ s/$prefix_strip_xdr{$into_module}//r);
    my $ret_unwrap = (@retvals == 1 ? $retvals[0]->{name} : '');
    push @{ $module_functions->{$into_module} //= [] }, {
        name => $entrypoint,
        const => $proc_const,
        args => \@callargs,
        ret  => \@retvals,
        retstr => ((not $ret_unwrap)
                   ? ('{ ' . join(', ',
                                  map { $_ . ' => $' . $_ }
                                  sort map { $_->{name} }  @retvals) . ' }')
                   : "\$$ret_unwrap"),
        ret_unwrap => $ret_unwrap,
    };
    my %mapped_retvals;
    for my $retval (@retvals) {
        if ($retval->{type}
            and $module{$retval->{type}}) {
            $mapped_retvals{$retval->{name}} = $retval->{type};
        }
    }
    if (%mapped_retvals or $ret_unwrap) {
        my $mapstr = join(', ',
                          map { "$_ => \\&_translate_$mapped_retvals{$_}" }
                          sort keys %mapped_retvals);
        $ret_unwrap = $ret_unwrap ? "'$ret_unwrap'" : 'undef';
        $module_returns->[$proc_value] =
            qq|sub { $proc_value; my \$client = shift; _translated(\$client, $ret_unwrap, { $mapstr }, \@_) }|;
    }
    else {
        $module_returns->[$proc_value] = '\&_no_translation';
    }
}

sub proc_entrypoint($module, $entrypoint) {
    if ($module eq $main_module) {
        my (@argnames) = map { $_->{name} } @{ $entrypoint->{args} };
        my $argstr = join(', ', map { '$' . $_ } @argnames);
        my $argsmap = join(', ', map { $_ . ' => $' . $_ . ($_ eq 'flags' ? ' // 0' : '') } @argnames);
        $entrypoint->{argstr} = $argstr;
        $entrypoint->{code} = <<~PROC;
        sub $entrypoint->{name} {
            my (\$self, $argstr) = \@_;
            return \$self->_call(
                \$remote->$entrypoint->{const},
                { $argsmap } );
        }
        PROC
    }
    else {
        my ($first_arg_name, @argnames) = map { $_->{name} } @{ $entrypoint->{args} };
        my $argstr = join(', ', map { '$' . $_ } @argnames);
        my $argsmap = join(', ', map { $_ . ' => $' . $_ . ($_ eq 'flags' ? ' // 0' : '') } @argnames);
        $entrypoint->{argstr} = $argstr;
        $entrypoint->{code} = <<~PROC;
        sub $entrypoint->{name} {
            my (\$self, $argstr) = \@_;
            return \$self->{client}->_call(
                \$remote->$entrypoint->{const},
                { $first_arg_name => \$self->{id}, $argsmap } );
        }
        PROC
    }
}

sub client($xdr_parse_version, $ast, $template, $h_syms) {
    my $procs = find_toplevel_definition($ast, 'remote_procedure');
    my @entrypoints;
    my (%module_functions, @module_returns); # returns are always in the client!

    for my $proc ( @{ $procs->{definition}->{type}->{declaration}->{elements} } ) {
        my $proc_annotation = join("\n", map { $_->{content} } @{ $proc->{comments} } );
        my $proc_name = $proc->{name}->{content};
        my $proc_value = $proc->{value}->{content};
        my $proc_const = ($proc_name =~ s/^REMOTE_//r);
        my $struct_basename = lc($proc_name =~ s/_PROC//r);

        if (my $msgstruct = find_toplevel_definition($ast, $struct_basename . '_msg')) {
            proc_msg($proc_annotation, \@module_returns, $msgstruct, $ast, $proc_value);
        }
        elsif ($proc_annotation =~ m/\@generate: (both|client)/) {
            proc_call($ast, \%module_functions, \@module_returns, $proc_value,
                      $proc_const, $struct_basename);
        }
        else {
            $module_returns[$proc_value] = '\&_no_translation';
        }
    }
    for my $key ( sort keys %module_functions ) {
        $module_functions{$key} = [ sort @{ $module_functions{$key} } ];
    }
    for my $module ( sort keys %module_functions ) {
        for my $entrypoint ( @{ $module_functions{$module} } ) {
            proc_entrypoint( $module, $entrypoint );
        }
    }

    my $translators = join(",\n    ", map { $_ // 'undef'} @module_returns);
    for my $mod ($main_module, values %module) {
        expand_mod_template($template,
                            $mod,
                            $h_syms,
                            \%module_functions,
                            $translators,
                            $xdr_parse_version);
    }
}

if (-d 'libvirt') {
    say "Deleting libvirt/...";
    system 'rm -rf libvirt/';
}
if (not -d '../libvirt') {
    system "git clone --depth 50 -b $tag  https://gitlab.com/libvirt/libvirt/ ../libvirt";
}


my $api_data    = extract_all( '../libvirt/' );
my $ast         = $api_data->{ast}->{remote};
my $header_syms = $api_data->{header_syms};

client($api_data->{xdr_parse_version},
       $ast,
       'templates/',
       $header_syms);
